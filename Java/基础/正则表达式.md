[toc]
## 符号
大写表示“非”，d表示digit数字。非数字就是\D, w表示word，非单词就是\W。

| 元字符       | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| \            | 将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\n。“\n”匹配换行符。序列“\\”匹配“\”而“\(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。 |
| ^            | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 |
| $            | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。 |
| *            | 匹配前面的子表达式任意次。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。*等价于o{0,} |
| +            | 匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 |
| ?            | 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。 |
| {n}          | n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 |
| {n,}         | n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 |
| {n,m}        | m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 |
| ?            | 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多的匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少的匹配“o”，得到结果 ['o', 'o', 'o', 'o'] |
| .点          | 匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。 |
| (pattern)    | 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。 |
| (?:pattern)  | 非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(\|)”来组合一个模式的各个部分时很有用。例如“industr(?:y\|ies)”就是一个比“industry\|industries”更简略的表达式。 |
| (?=pattern)  | 非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95\|98\|NT\|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| (?!pattern)  | 非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95\|98\|NT\|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。 |
| (?<=pattern) | 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?<=95\|98\|NT\|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 |
| (?<!pattern) | 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?<!95\|98\|NT\|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题此处用或任意一项都不能超过2位，如“(?<!95\|98\|NT\|20)Windows正确，“(?<!95\|980\|NT\|20)Windows 报错，若是单独使用则无限制，如(?<!2000)Windows 正确匹配 |
| x\|y         | 匹配x或y。例如，“z\|food”能匹配“z”或“food”(此处请谨慎)。“[zf]ood”则匹配“zood”或“food”。 |
| [xyz]        | 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 |
| [^xyz]       | 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。 |
| [a-z]        | 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身. |
| [^a-z]       | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 |
| \b           | 匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 |
| \B           | 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 |
| \cx          | 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 |
| \d           | 匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持   |
| \D           | 匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持 |
| \f           | 匹配一个换页符。等价于\x0c和\cL。                            |
| \n           | 匹配一个换行符。等价于\x0a和\cJ。                            |
| \r           | 匹配一个回车符。等价于\x0d和\cM。                            |
| \s           | 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 |
| \S           | 匹配任何可见字符。等价于[^ \f\n\r\t\v]。                     |
| \t           | 匹配一个制表符。等价于\x09和\cI。                            |
| \v           | 匹配一个垂直制表符。等价于\x0b和\cK。                        |
| \w           | 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的"单词"字符使用Unicode字符集。 |
| \W           | 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。                  |



## 元字符

万物皆有缘，正则也是如此，元字符是构造正则表达式的一种基本元素。

我们先来记几个常用的元字符：

| 元字符 | 说明                         |
| ------ | ---------------------------- |
| .      | 匹配除换行符以外的任意字符   |
| \w     | 匹配字母或数字或下划线或汉字 |
| \s     | 匹配任意的空白符             |
| \d     | 匹配数字                     |
| \b     | 匹配单词的开始或结束         |
| ^      | 匹配字符串的开始             |
| $      | 匹配字符串的结束             |

有了元字符之后，我们就可以利用这些元字符来写一些简单的正则表达式了，

比如：

匹配有abc开头的字符串



1\babc或者^abc 



匹配8位数字的QQ号码



1^\d\d\d\d\d\d\d\d$  

匹配1开头11位数字的手机号码

 1^1\d\d\d\d\d\d\d\d\d\d$ 

## 重复限定符

有了元字符就可以写不少的正则表达式了，但细心的你们可能会发现：别人写的正则简洁明了，而不理君写的正则一堆乱七八糟而且重复的元字符组成的。正则没提供办法处理这些重复的元字符吗？

答案是有的！

为了处理这些重复问题，正则表达式中一些重复限定符，把重复部分用合适的限定符替代，下面我们来看一些限定符：

| 语法  | 说明             |
| ----- | ---------------- |
| *     | 重复零次或更多次 |
| +     | 重复一次或更多次 |
| ?     | 重复零次或一次   |
| {n}   | 重复n次          |
| {n,}  | 重复n次或更多次  |
| {n,m} | 重复n到m次       |

有了这些限定符之后，我们就可以对之前的正则表达式进行改造了，比如：

匹配8位数字的QQ号码

^\d{8}$ 

匹配1开头11位数字的手机号码

^1\d{10}$ 

匹配银行卡号是14~18位的数字

^\d{14,18}$ 

匹配以a开头的，0个或多个b结尾的字符串

^ab*$ 

## 分组

从上面的例子（4）中看到，*限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要ab同时被*限定那怎么办呢？

正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。

因此当我们要匹配多个ab时，我们可以这样。如：匹配字符串中包含0到多个ab开头：

^(ab)* 

**4. 转义**

我们看到正则表达式用小括号来做分组，那么问题来了：

如果要匹配的字符串中本身就包含小括号，那是不是冲突？应该怎么办？

针对这种情况，正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。

如：要匹配以(ab)开头：

^(\(ab\))* 

## 条件或

回到我们刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有130/131/132/155/156/185/186/145/176等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？

正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。

那么我们就可以用或条件来处理这个问题

^(130|131|132|155|156|185|186|145|176)\d{8}$ 

##  区间

看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？

实际是有的

正则提供一个元字符中括号 [] 来表示区间条件。

1. 限定0到9 可以写成[0-9]
2. 限定A-Z 写成[A-Z]
3. 限定某些数字 [165]

那上面的正则我们还改成这样：

^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$ 


## 常用正则


一、校验数字的表达式
数字：

```
^[0-9]\*$
n位的数字：
^\d{n}$
至少n位的数字：
^\d{n,}$
m-n位的数字：
^\d{m,n}$
零和非零开头的数字：
^(0|[1-9][0-9]\*)$
非零开头的最多带两位小数的数字：
^([1-9][0-9]\*)+(\.[0-9]{1,2})?$
带1-2位小数的正数或负数：
^(\-)?\d+(\.\d{1,2})$
正数、负数、和小数：
^(\-|\+)?\d+(\.\d+)?$
有两位小数的正实数：
^[0-9]+(\.[0-9]{2})?$
有1~3位小数的正实数：
^[0-9]+(\.[0-9]{1,3})?$
非零的正整数：
^[1-9]\d\*$ 或 ^([1-9][0-9]\*){1,3}$ 或 ^\+?[1-9][0-9]\*$
非零的负整数：
^\-[1-9][]0-9"\*$ 或 ^-[1-9]\d\*$
非负整数：
^\d+$ 或 ^[1-9]\d\*|0$
非正整数：
^-[1-9]\d\*|0$ 或 ^((-\d+)|(0+))$
非负浮点数：
^\d+(\.\d+)?$ 或 ^[1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*|0?\.0+|0$
非正浮点数：
^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*))|0?\.0+|0$
正浮点数：
^[1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*$ 或 ^(([0-9]+\.[0-9]\*[1-9][0-9]\*)|([0-9]\*[1-9][0-9]\*\.[0-9]+)|([0-9]\*[1-9][0-9]\*))$
负浮点数：
^-([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*)$ 或 ^(-(([0-9]+\.[0-9]\*[1-9][0-9]\*)|([0-9]\*[1-9][0-9]\*\.[0-9]+)|([0-9]\*[1-9][0-9]\*)))$
浮点数：
^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*|0?\.0+|0)$
```


二、校验字符的表达式
汉字：

```
^[\u4e00-\u9fa5]{0,}$
英文和数字：
^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
长度为3-20的所有字符：
^.{3,20}$
由26个英文字母组成的字符串：
^[A-Za-z]+$
由26个大写英文字母组成的字符串：
^[A-Z]+$
由26个小写英文字母组成的字符串：
^[a-z]+$
由数字和26个英文字母组成的字符串：
^[A-Za-z0-9]+$
由数字、26个英文字母或者下划线组成的字符串：
^\w+$ 或 ^\w{3,20}$
中文、英文、数字包括下划线：
^[\u4E00-\u9FA5A-Za-z0-9_]+$
中文、英文、数字但不包括下划线等符号：
^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
禁止输入含有~的字符：
[^~\x22]+
```

三、特殊需求表达式
Email地址：

```
^\w+([-+.]\w+)\*@\w+([-.]\w+)\*\.\w+([-.]\w+)\*$
```

域名：

```
[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
InternetURL：
[a-zA-z]+://[^\s]\* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]\*)?$
```

手机号码：

```
^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
```

国内电话号码(0511-4405222、021-87888822)：
```
\d{3}-\d{8}|\d{4}-\d{7}
```

电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）:
```
 ((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)
 ```
身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：
```
(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)
```
帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：
```
^[a-zA-Z][a-zA-Z0-9_]{4,15}$
```
密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：
```
^[a-zA-Z]\w{5,17}$
```
强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：
```
^(?=.\*\d)(?=.\*[a-z])(?=.\*[A-Z])[a-zA-Z0-9]{8,10}$
```
强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：
```
^(?=.\*\d)(?=.\*[a-z])(?=.\*[A-Z]).{8,10}$
```
日期格式：
```
^\d{4}-\d{1,2}-\d{1,2}
```
一年的12个月(01～09和1～12)：
```
^(0?[1-9]|1[0-2])$
```
一个月的31天(01～09和1～31)：
```
^((0?[1-9])|((1|2)[0-9])|30|31)$
```
xml文件：
```
^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
```
中文字符的正则表达式：
```
[\u4e00-\u9fa5]
```
空白行的正则表达式：
```
\n\s\*\r (可以用来删除空白行)
```
HTML标记的正则表达式：
```
<(\S\*?)[^>]\*>.\*?|<.\*? /> (
```
首尾空白字符的正则表达式：(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
```
^\s\*|\s\*$或(^\s\*)|(\s\*$)
``` 


腾讯QQ号：
```
[1-9][0-9]{4,} (腾讯QQ号从10000开始)
```
中国邮政编码：
```
[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)
```
IP地址：
```
((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))
```
