# 目录
[toc]


## 时间

JDK 8 之前的时间操作

1 获取时间

```
Date date = new Date();
System.out.println(date);
Calendar calendar = Calendar.getInstance();
Date time = calendar.getTime();
System.out.println(time);
```

2 获取时间戳

```
long ts = new Date().getTime();
System.out.println(ts);
long ts2 = System.currentTimeMillis();
System.out.println(ts2);
long ts3 = Calendar.getInstance().getTimeInMillis();
System.out.println(ts3);
```

3 格式化时间

```
SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
System.out.println(sf.format(new Date()));  // output:2019-08-16 21:46:22
```

SimpleDateFormat 构造参数的含义，请参考以下表格信息：
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190923101239.png)
使用示例：


```
获取星期几：new SimpleDateFormat("E").format(new Date())
获取当前时区：new SimpleDateFormat("Z").format(new Date*())
```

注意事项：在多线程下 SimpleDateFormat 是非线程安全的，因此在使用 SimpleDateFormat 时要注意这个问题。在多线程下，如果使用不当，可能会造成结果不对或内存泄漏等问题。

4 时间转换

```
SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
// String 转 Date
String str = "2019-10-10 10:10:10";
System.out.println(sf.parse(str));
//时间戳的字符串 转 Date
String tsString = "1556788591462";
// import java.sql
Timestamp ts = new Timestamp(Long.parseLong(tsString)); // 时间戳的字符串转 Date
System.out.println(sf.format(ts));
```
**注意事项**：当使用 SimpleDateFormat.parse() 方法进行时间转换的时候，SimpleDateFormat 的构造函数必须和待转换字符串格式一致。

5 获得昨天此刻时间

```
Calendar calendar = Calendar.getInstance();
calendar.add(Calendar.DATE, -1);
System.out.println(calendar.getTime());
```


## JDK8新增和线程安全
==SimpleDateFormat 不是线程安全的，线程安全的话需要每次调用都生成一个类，或者使用DataTimeFormatter。==

JDK 8 对时间操作新增了三个类：LocalDateTime、LocalDate、LocalTime。

- LocalDate 只包含日期，不包含时间，不可变类，且线程安全。
- LocalTime 只包含时间，不包含日期，不可变类，且线程安全。
- LocalDateTime 既包含了时间又包含了日期，不可变类，且线程安全。
 
线程安全性：值得一提的是 JDK 8 中新增的这三个时间相关的类，都是线程安全的，这极大地降低了多线程下代码开发的风险。

1 获取时间

```
// 获取日期
LocalDate localDate = LocalDate.now();
System.out.println(localDate);    // output:2019-08-16
// 获取时间
LocalTime localTime = LocalTime.now();
System.out.println(localTime);    // output:21:09:13.708
// 获取日期和时间
LocalDateTime localDateTime = LocalDateTime.now();
System.out.println(localDateTime);    // output:2019-08-16T21:09:13.708
```

2 获取时间戳

```
long milli = Instant.now().toEpochMilli(); // 获取当前时间戳（精确到毫秒）
long second = Instant.now().getEpochSecond(); // 获取当前时间戳（精确到秒）
System.out.println(milli);  // output:1565932435792
System.out.println(second); // output:1565932435
```

3 时间格式化

```
// 时间格式化①
DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
String timeFormat = dateTimeFormatter.format(LocalDateTime.now());
System.out.println(timeFormat);  // output:2019-08-16 21:15:43
// 时间格式化②
String timeFormat2 = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
System.out.println(timeFormat2);    // output:2019-08-16 21:17:48
```

4 时间转换

```
String timeStr = "2019-10-10 06:06:06";
LocalDateTime dateTime = LocalDateTime.parse(timeStr,DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
System.out.println(dateTime);
```

5 获得昨天此刻时间

```
LocalDateTime today = LocalDateTime.now();
LocalDateTime yesterday = today.plusDays(-1);
System.out.println(yesterday);
```


## 其他
使用 Date 类的默认无参构造方法创建出的对象就代表当前时间，我们可以直接输出 Date 对象显示当前的时间，显示的结果如下：

```
public static void main(String[] args){
        Date date = new Date();
        System.out.println(date); // Mon Feb 11 21:58:30 CST 2019
}



//转换时格式间  Date和SimpleDateFormat
//yyyy 表示四位年， MM 表示两位月份， dd 表示两位日期， HH 表示小时(使用24小时制)， mm 表示分钟， ss 表示秒

// 使用 format() 方法将日期转换为指定格式的文本
Date datenow = new Date();
SimpleDateFormat ft = new SimpleDateFormat("yyyy.MM.dd hh:mm:ss");
System.out.println(ft.format(datenow));
```




注意：
1. 调用 SimpleDateFormat 对象的 parse() 方法时可能会出现转换异常，即 ParseException ，因此需要进行异常处理
2. 使用 Date 类时需要导入 java.util 包，使用 SimpleDateFormat 时需要导入 java.text 


示例代码：

```
public static void main(String[] args){
        
        // 使用format()方法将日期转换为指定格式的文本
        SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒");
        SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy/MM/dd HH:mm");
        SimpleDateFormat sdf3 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        
        // 创建Date对象，表示当前时间
        Date  now = new Date();
        
        // 调用format()方法，将日期转换为字符串并输出
        System.out.println(sdf1.format(now));//2019年02月11日 21时50分48秒
        System.out.println(sdf2.format(now));//2019/02/11 21:50
        System.out.println(sdf3.format(now));//2019-02-11 21:50:48

        // 使用parse()方法将文本转换为日期
        String d = "2019-2-11 21:50:36";
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    
         
         // 调用parse()方法，将字符串转换为日期
         try {   //注意一定要和指定的格式匹配
              Date date =sdf.parse(d);
              System.out.println(date);//Mon Feb 11 21:50:36 CST 2019
         }catch(ParseException e){
             e.printStackTrace();
         } 
}
```



## SimpleDateFormat 时间格式化
Java 的Calendar, Date和DateFormat的关系图如下：
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/dcalendar.png)

说明：
(01) milliseconds 表示毫秒。
     
milliseconds = “实际时间” - “1970-01-01 00:00:00”。Calendar 和 Date依赖于 milliseconds，从而表示时间。

(02) Calendar表示日期/时间。

它是一个抽象类，依赖于milliseconds。GregorianCalendar是Calendar的子类，通常我们通过Calendar.getInstance() 获取Calendar实例时，实际上返回的是 GregorianCalendar 对象。
     
     
Calendar和Locale关联，而Locale代表区域；Locale的值不同时，Calendar的日期/时间也不同。

Calendar和TimeZone关联，而TimeZone代表时区；不同的时区，Calendar的日期/时间也不同。

(03) Date 表示日期/时间。它也依赖于 milliseconds实现。
     
在 JDK 1.1 之前，通常是通过Data操作“年月日时分秒”。不过，由于Date的相关 API 不易于实现国际化。从 JDK 1.1 开始，应该使用 Calendar 类来操作“年月日时分秒”，同时可以通过 DateFormat 类来格式化和解析日期字符串。Date 中的相应方法已废弃。

(04) DateFormat是格式化/解析“日期/时间”的工具类。

它是Date的格式化工具，它能帮助我们格式化Date，进而将Date转换成我们想要的String字符串供我们使用。

它是一个抽象类。通常，我们通过getInstance(), getDateInstance()和getDateTimeInstance() 等获取DateFormat实例时；实际上是返回的SimpleDateFormat对象。

## Calendar介绍
Calendar 是一个抽象类：它的实现，采用了设计模式中的工厂方法。表现在：当我们获取Calendar实例时，Calendar会根据传入的参数来返回相应的Calendar对象。

获取Calendar实例，有以下两种方式：

1. 当我们通过 Calendar.getInstance() 获取日历时，默认的是返回的一个GregorianCalendar对象。  GregorianCalendar是Calendar的一个实现类，它提供了世界上大多数国家/地区使用的标准日历系统。

2. 当我们通过 Calendar.getInstance(TimeZone timezone, Locale locale) 或 Calendar.getInstance(TimeZone timezone) 或 Calendar.getInstance(Locale locale)获取日历时，是返回“对应时区(zone) 或 地区(local)等所使用的日历”。例如，若是日本，则返回JapaneseImperialCalendar对象。


```
//例子
public static Calendar getInstance()
{
    // 调用createCalendar()创建日历
    Calendar cal = createCalendar(TimeZone.getDefaultRef(), Locale.getDefault());
    cal.sharedZone = true;
    return cal;
}


public static Calendar getInstance(TimeZone zone)
{
    // 调用createCalendar()创建日历
    return createCalendar(zone, Locale.getDefault());
}


public static Calendar getInstance(Locale aLocale) {
    // 调用createCalendar()创建日历
    Calendar cal = createCalendar(TimeZone.getDefaultRef(), aLocale);
    cal.sharedZone = true;
    return cal;
}

public static Calendar getInstance(TimeZone zone,
                   Locale aLocale)
{
    // 调用createCalendar()创建日历
    return createCalendar(zone, aLocale);
}

private static Calendar createCalendar(TimeZone zone,
                   Locale aLocale)
{
    // (01) 若地区是“th”，则返回BuddhistCalendar对象
    // (02) 若地区是“JP”，则返回JapaneseImperialCalendar对象
    if ("th".equals(aLocale.getLanguage())
        && ("TH".equals(aLocale.getCountry()))) {
        return new sun.util.BuddhistCalendar(zone, aLocale);
    } else if ("JP".equals(aLocale.getVariant())
       && "JP".equals(aLocale.getCountry())
       && "ja".equals(aLocale.getLanguage())) {
        return new JapaneseImperialCalendar(zone, aLocale);
    }        

    // (03) 否则，返回GregorianCalendar对象
    return new GregorianCalendar(zone, aLocale);    
}
```
[万年历和自定义Calendar接口](http://wangkuiwu.github.io/2012/04/02/time/)

## Calendar的原理和思想
Calendar就是以一个time(毫秒)为基数，而计算出“年月日时分秒”等，从而方便我们对“年月日时分秒”等进行操作。

1. Calendar 各个字段值的来源
我们使用Calendar，无非是使用“年、月、日、星期、时、分、秒”等信息。那么它是如何做到的呢？ 本质上，Calendar就是保存了一个时间。如下定义：

    Calendar就是根据 time 计算出 “Calendar的年、月、日、星期、时、分、秒”等等信息。

```
// time 是当前时间，单位是毫秒。
// 它是当前时间距离“January 1, 1970, 0:00:00 GMT”的差值。
protected long time;
```

2. Calendar 各个字段的定义和初始化
Calendar 的“年、月、日、星期、时、分、秒”这些信息，一共是17个字段。
我们使用Calendar，无非是就是使用这17个字段。它们的定义如下：

```
(字段0) public final static int ERA = 0;
说明：纪元。
取值：只能为0 或 1。0表示BC(“before Christ”,即公元前)，1表示AD(拉丁语“Anno Domini”,即公元)。
(字段1) public final static int YEAR = 1;
说明：年。
(字段2) public final static int MONTH = 2;
说明：月
取值：可以为，JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER, UNDECIMBER。
     其中第一个月是 JANUARY，它为 0。
(字段3) public final static int WEEK_OF_YEAR = 3;
说明：当前日期在本年中对应第几个星期。一年中第一个星期的值为 1。
(字段4) public final static int WEEK_OF_MONTH = 4;
说明：当前日期在本月中对应第几个星期。一个月中第一个星期的值为 1。
(字段5) public final static int DATE = 5;
说明：日。一个月中第一天的值为 1。
(字段5) public final static int DAY_OF_MONTH = 5;
说明：同“DATE”，表示“日”。
(字段6) public final static int DAY_OF_YEAR = 6;
说明：当前日期在本年中对应第几天。一年中第一天的值为 1。
(字段7) public final static int DAY_OF_WEEK = 7;
说明：星期几。
取值：可以为，SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY 和 SATURDAY。
     其中，SUNDAY为1，MONDAY为2，依次类推。
(字段8) public final static int DAY_OF_WEEK_IN_MONTH = 8;
说明：当前月中的第几个星期。
取值：DAY_OF_MONTH 1 到 7 总是对应于 DAY_OF_WEEK_IN_MONTH 1；8 到 14 总是对应于 DAY_OF_WEEK_IN_MONTH 2，依此类推。
(字段9) public final static int AM_PM = 9;
说明：上午 还是 下午
取值：可以是AM 或 PM。AM为0,表示上午；PM为1,表示下午。
(字段10) public final static int HOUR = 10;
说明：指示一天中的第几小时。
     HOUR 用于 12 小时制时钟 (0 - 11)。中午和午夜用 0 表示，不用 12 表示。
(字段11) public final static int HOUR_OF_DAY = 11;
说明：指示一天中的第几小时。
     HOUR_OF_DAY 用于 24 小时制时钟。例如，在 10:04:15.250 PM 这一时刻，HOUR_OF_DAY 为 22。
(字段12) public final static int MINUTE = 12;
说明：一小时中的第几分钟。
例如，在 10:04:15.250 PM这一时刻，MINUTE 为 4。
(字段13) public final static int SECOND = 13;
说明：一分钟中的第几秒。
例如，在 10:04:15.250 PM 这一时刻，SECOND 为 15。
(字段14) public final static int MILLISECOND = 14;
说明：一秒中的第几毫秒。
例如，在 10:04:15.250 PM 这一时刻，MILLISECOND 为 250。
(字段15) public final static int ZONE_OFFSET = 15;
说明：毫秒为单位指示距 GMT 的大致偏移量。
(字段16) public final static int DST_OFFSET = 16;
说明：毫秒为单位指示夏令时的偏移量。
public final static int FIELD_COUNT = 17;
```

这17个字段是保存在int数组中。定义如下：

```
// 保存这17个字段的数组
protected int           fields[];
// 数组的定义函数
protected Calendar(TimeZone zone, Locale aLocale)
{
    // 初始化“fields数组”
    fields = new int[FIELD_COUNT];
    isSet = new boolean[FIELD_COUNT];
    stamp = new int[FIELD_COUNT];

    this.zone = zone;
    setWeekCountData(aLocale);
}
```
protected Calendar(TimeZone zone, Locale aLocale) 这是Calendar的构造函数。它会被它的子类的构造函数调用到，从而新建“保存Calendar的17个字段数据”的数组。

## Calendar 各个字段值的计算
下面以get(int field)为例，简要的说明Calendar的17个字段的计算和操作。 get(int field)是获取“field”字段的值。它的定义如下：

```
public int get(int field) {
    // 计算各个字段的值
    complete();
    // 返回field字段的值
    return internalGet(field);
}
```
说明：get(int field)的代码很简单。先通过 complete() 计算各个字段的值，然后在通过 internalGet(field) 返回“field字段的值”。

complete() 的作用就是计算Calendar各个字段的值。它定义在Calendar.java中，代码如下：
```
protected void complete()
{
    if (!isTimeSet)
    updateTime();
    if (!areFieldsSet || !areAllFieldsSet) {
        computeFields(); // fills in unset fields
        areAllFieldsSet = areFieldsSet = true;
    }
}
private void updateTime() {
    computeTime();
    isTimeSet = true;
}
//updateTime() 调用到的 computeTime() 定义在 Calendar.java的实现类中。
```
## Calendar函数接口

#### Calendar的17个字段的公共接口
Calendar的这17个字段，都支持下面的公共函数接口。 这些公共接口的使用示例，请参考CalendarTest.java 示例中的 testAllCalendarSections() 函数。

1. getMaximum(int field)
作用：获取“字段的最大值”。注意“对比它和 getActualMaximum() 的区别”。 示例：以“MONTH”字段来说。使用方法为：
```
// 获取Calendar实例
Calendar cal = Calendar.getInstance();
// 获取MONTH的最大值
int max = cal.getMaximum(Calendar.MONTH);
```
若要获取其它字段的最大值，只需要将示例中的MONTH相应的替换成其它字段名即可。

2. getActualMaximum(int field)
作用：获取“当前日期下，该字段的最大值”。 示例：以“MONTH”字段来说。使用方法为：
```
// 获取Calendar实例
Calendar cal = Calendar.getInstance();
// 获取当前MONTH的最大值
int max = cal.getActualMaximum(Calendar.MONTH);

```
若要获取其它字段的最大值，只需要将示例中的MONTH相应的替换成其它字段名即可。

注意：对比getActualMaximum() 和 getMaximum() 的区别。参考下面的对比示例，
(01) getMaximum() 获取的“字段最大值”，是指在综合所有的日期，在所有这些日期中得出的“字段最大值”。
    
例如，getMaximum(Calendar.DATE)的目的是“获取‘日的最大值’”。综合所有的日期，得出一个月最多有31天。因此，getMaximum(Calendar.DATE)的返回值是“31”！
(02) getActualMaximum() 获取的“当前日期时，该字段的最大值”。
     
例如，当日期为2013-09-01时，getActualMaximum(Calendar.DATE)是获取“日的最大值”是“30”。当前日期是9月份，而9月只有30天。因此，getActualMaximum(Calendar.DATE)的返回值是“30”！

3. getMinimum(int field)
作用：获取“字段的最小值”。注意“对比它和 getActualMinimum() 的区别”。 示例：以“MONTH”字段来说。使用方法为：
```
// 获取Calendar实例
Calendar cal = Calendar.getInstance();
// 获取MONTH的最小值
int min = cal.getMinimum(Calendar.MONTH);
```

若要获取其它字段的最小值，只需要将示例中的MONTH相应的替换成其它字段名即可。

4. getActualMinimum(int field)
作用：获取“当前日期下，该字段的最小值”。 示例：以“MONTH”字段来说。使用方法为：
```
// 获取Calendar实例
Calendar cal = Calendar.getInstance();
// 获取MONTH的最小值
int min = cal.getMinimum(Calendar.MONTH);
```
若要获取其它字段的最小值，只需要将示例中的MONTH相应的替换成其它字段名即可。

注意：在Java默认的Calendar中，虽然 getMinimum() 和 getActualMinimum() 的含义不同；但是，它们的返回值是一样的。因为Calendar的默认是返回GregorianCalendar对象，而在GregorianCalendar.java中，getMinimum() 和 getActualMinimum() 返回值一样。

5. get(int field)
作用：获取“字段的当前值”。获取field字段的当前值。 示例：以“MONTH”字段来说。“获取MONTH的当前值”的方法为
```
// 获取Calendar实例
Calendar cal = Calendar.getInstance();
// 获取“cal日历”的当前MONTH值
int MONTH = cal.get(Calendar.MONTH);

```
若要获取其它字段的当前值，只需要将示例中的MONTH相应的替换成其它字段名

6. set(int field, int value)
作用：设置“字段的当前值”。设置field字段的当前值为value 示例：以“MONTH”字段来说。“设置MONTH的当前值”的方法为：
```
// 获取Calendar实例
Calendar cal = Calendar.getInstance();
// 设置“cal日历”的当前MONTH值为 1988年
cal.set(Calendar.MONTH, 1988);
```
说明：
- (01) 1988 是想要设置的MONTH的当前值。这个设置值必须是整数。
- (02) 若要设置其它字段的当前值，只需要将示例中的MONTH相应的替换成其它字段名即可。

7. add(int field, int value)
作用：给“字段的当前值”添加值。给field字段的当前值添加value。 示例：以“MONTH”字段来说。方法如下：

```
// 获取Calendar实例，并设置日期为“2013-09-01”
Calendar cal = Calendar.getInstance();
cal.set(Calendar.YEAR, 2013);
cal.set(Calendar.MONTH, 8);
cal.set(Calendar.DATE, 1);
// 给“cal日历”的当前MONTH值 “添加-10”
cal.add(Calendar.MONTH, -10);
```
说明：

(01) -10 是添加值。
     添加值可以为正数，也可以是负数。
     正数表示将日期增加，负数表示将日期减少。
     假设：现在cal的值是“2013-09-01”，现在我们将MONTH字段值增加-10。得到的结果是：“2012-10-01”。
     为什么会这样呢？“2013-09-01”增加-10，也就是将日期向前减少10个月；得到的结果就是“2012-10-01”。

(02) Calendar的17个字段中：除了回滚Calendar.ZONE_OFFSET时，会抛出IllegalArgumentException异常；其它的字段都支持该操作。

(03) 若要设置其它字段的当前值，只需要将示例中的MONTH相应的替换成其它字段名即可。

8. roll(int field, int value)
作用：回滚“字段的当前值” 示例：以“MONTH”字段来说。“回滚MONTH的当前值”的方法为：
```
// 获取Calendar实例，并设置日期为“2013-09-01”
Calendar cal = Calendar.getInstance();
cal.set(Calendar.YEAR, 2013);
cal.set(Calendar.MONTH, 8);
cal.set(Calendar.DATE, 1);
// 将“cal日历”的当前MONTH值 “向前滚动10”
cal.roll(Calendar.MONTH, -10);

```

说明：

(01) -10 是回滚值。
     当回滚值是负数时，表示将当前字段向前滚；
     当回滚值是正数时，表示将当前字段向后滚。
     回滚Calendar中某一字段时，不更改更大的字段！
     这是roll()与add()的根据区别！add()可能会更改更大字段，比如“使用add()修改‘MONTH’字段，可能会引起‘YEAR’字段的改变”；但是roll()不会更改更大的字段，例如“使用roll()修改‘MONTH’字段，不回引起‘YEAR’字段的改变。”
     假设：现在cal的值是“2013-09-01”，现在我们将MONTH字段值增加-10。得到的结果是：“2013-10-01”。
     为什么会这样呢？这就是因为“回滚”就是“在最小值和最大值之间来回滚动”。本例中，MONTH是9月，前回滚10，得到的值是10月，但是roll()不会改变“比MONTH”更大的字段，所以YEAR字段不会改变。所以结果是“2013-10-01”。

(02) Calendar的17个字段中：除了回滚Calendar.ZONE_OFFSET时，会抛出IllegalArgumentException异常；其它的字段都支持该操作。

(03) 若要设置其它字段的当前值，只需要将示例中的MONTH相应的替换成其它字段名即可。

9. clear(int field)
作用：清空“字段的当前值”。所谓清空，实际上是将“field”的值设置为0；若field最小值为1,则设置为1。 示例：以“MONTH”字段来说。“清空MONTH”的方法为：

```
// 获取Calendar实例，并设置日期为“9月”
Calendar cal = Calendar.getInstance();
cal.set(Calendar.MONTH, 9);
// 清空MONTH
cal.clear(Calendar.MONTH);
```


若要清空其它字段，只需要将示例中的MONTH相应的替换成其它字段名即可。

10. isSet(int field)
作用：判断“字段field”是否被设置。若调用clear()清空之后，则field变为“没有设置状态”。 示例：以“MONTH”字段来说。“判断MONTH是否被设置”的方法为：

```
// 获取Calendar实例
Calendar cal = Calendar.getInstance();
// 判断MONTH是否被设置
boolean bset = cal.isSet(Calendar.MONTH);
```


若要判断其它字段，只需要将示例中的MONTH相应的替换成其它字段名即可。

#### 2. Calendar的其它函数
1) 日期比较函数
Calendar的比较函数，主要有以下几个：

```
// 比较“当前Calendar对象”和“calendar” 的日期、时区等内容是否相等。
boolean equals(Object object)
// 当前Calendar对象 是否 早于calendar
boolean before(Object calendar)
// 当前Calendar对象 是否 晚于calendar
boolean after(Object calendar)
// 比较“当前Calendar对象”和“calendar”。
// 若 早于 “calendar” 则，返回-1
// 若 相等， 则，返回0
// 若 晚于 “calendar” 则，返回1
int compareTo(Calendar anotherCalendar)
```


这些函数的使用示例，请参考CalendarTest.java示例中的 testComparatorAPIs() 函数。
示例：假设cal1 和 cal2 都是Calendar的两个对象。
```
// 它们的使用方法如下
boolean isEqual = cal1.equals(cal2);
boolean isBefore = cal1.before(cal2);
boolean isAfter = cal1.after(cal2);
int icompare = cal1.compareTo(cal2);
```
2) “宽容”函数

```
// 设置“Calendar的宽容度”
void setLenient(boolean value)
// 获取“Calendar的宽容度”
boolean isLenient()
```
这些函数的使用示例，请参考CalendarTest.java示例中的 testLenientAPIs() 函数。
说明：
Calendar 有两种解释日历字段的模式，即 lenient 和 non-lenient。

(01) 当 Calendar 处于 lenient 模式时，它可接受比它所生成的日历字段范围更大范围内的值。当 Calendar 重新计算日历字段值，以便由 get() 返回这些值时，所有日历字段都被标准化。
     例如，lenient 模式下的 GregorianCalendar 将 MONTH == JANUARY、DAY_OF_MONTH == 32 解释为 February 1。

(02) 当 Calendar 处于 non-lenient 模式时，如果其日历字段中存在任何不一致性，它都会抛出一个异常。
     例如，GregorianCalendar 总是在 1 与月份的长度之间生成 DAY_OF_MONTH 值。如果已经设置了任何超出范围的字段值，那么在计算时间或日历字段值时，处于 non-lenient 模式下的 GregorianCalendar 会抛出一个异常。
注意：在(02)步骤中的异常，在使用set()时不会抛出，而需要在使用get()、getTimeInMillis()、getTime()、add() 和 roll() 等函数中才抛出。因为set()只是设置了一个修改标志，而get()等方法才会引起时间的重新计算，此时才会抛出异常


3) "年月日(时分秒)"、Date、TimeZone、MilliSecond函数

```
// 设置“年月日”
final void     set(int year, int month, int day)
// 设置“年月日时分”
final void     set(int year, int month, int day, int hourOfDay, int minute, int second)
// 设置“年月日时分秒”
final void     set(int year, int month, int day, int hourOfDay, int minute)
// 获取Calendar对应的日期
final Date     getTime()
// 设置Calendar为date
final void    setTime(Date date)
// 获取Calendar对应的时区
TimeZone     getTimeZone()
// 设置Calendar对应的时区
void     setTimeZone(TimeZone timezone)
// 获取Calendar对应的milliscondes值，就是“Calendar当前日期”距离“1970-01-01 0:00:00 GMT”的毫秒数
long     getTimeInMillis()
// 设置Calendar对应的milliscondes值
void     setTimeInMillis(long milliseconds)
```


这些函数的使用示例，请参考CalendarTest.java示例中的 testTimeAPIs() 函数。

4) 其它操作

```
// 克隆Calendar
Object clone()
// 获取“每周的第一天是星期几”。例如，在美国，这一天是 SUNDAY，而在法国，这一天是 MONDAY。
int getFirstDayOfWeek()
// 设置“每周的第一天是星期几”。例如，在美国，这一天是 SUNDAY，而在法国，这一天是 MONDAY。
void setFirstDayOfWeek(int value)
// 获取一年中第一个星期所需的最少天数，例如，如果定义第一个星期包含一年第一个月的第一天，则此方法将返回 1。如果最少天数必须是一整个星期，则此方法将返回 7。
int getMinimalDaysInFirstWeek()
// 设置一年中第一个星期所需的最少天数，例如，如果定义第一个星期包含一年第一个月的第一天，则使用值 1 调用此方法。如果最少天数必须是一整个星期，则使用值 7 调用此方法。
void setMinimalDaysInFirstWeek(int value)
```


这些函数的使用示例，请参考CalendarTest.java示例中的 testOtherAPIs() 函数。

## 例子总结

```java
import java.util.Date;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.Random;

/**
 * Calendar的API测试程序
 *
 * @author skywang 
 * @email kuiwu-wang@163.com
 */
public class CalendarTest {

    public static void main(String[] args) {

        // 测试Calendar的“17个字段的公共函数接口”
        testAllCalendarSections() ;

        // 测试Calendar的“比较接口”
        testComparatorAPIs() ;

        // 测试Calendar的“比较接口”
        testLenientAPIs() ;

        // 测试Calendar的Date、TimeZone、MilliSecond等相关函数
        testTimeAPIs() ;

        // 测试Calendar的clone()，getFirstDayOfWeek()等接口
        testOtherAPIs() ;

    }


    /**
     * 测试“Calendar的字段”
     *
     * @param cal   -- Calendar对象
     * @param field -- 要测试的“Calendar字段”。可以为以下值：
     *   Calendar.YEAR, Calendar.MONTH, Calendar.DATE, ... 等等
     * @param title -- 标题
     * @author skywang (kuiwu-wang@163.com)
     */
    private static void testSection(Calendar cal, int field, String title) {
        final Random random = new Random();
        final Date date = cal.getTime();

        final int min = cal.getMinimum(field);    // 获取"字段最小值"
        final int max = cal.getMaximum(field);    // 获取“字段最大值”

        final int actualMin = cal.getActualMinimum(field);    // 获取"当前日期下，该字段最小值"
        final int actualMax = cal.getActualMaximum(field);    // 获取“当前日期下，该字段的最大值”

        // 获取“字段的当前值”
        final int ori = cal.get(field);            

        // 设置“字段的当前值”, 并获取“设置之后的值”
        final int r1 = random.nextInt(max);
        cal.set(field, r1);                
        final int set = cal.get(field);            
        try {
            // 回滚“字段的当前值”：在“字段最小值”和“字段最大值”之间回滚。
            // “回滚值”可以为正，也可以为负。
            cal.roll(field, -max);            
        } catch (IllegalArgumentException e) {
            // 当field == Calendar.ZONE_OFFSET时，会抛出该异常！
            e.printStackTrace();
        }
        final int roll = cal.get(field);            

        // 获取一个随机值
        final int sign = ( random.nextInt(2) == 1) ? 1 : -1;
        final int r2 = sign * random.nextInt(max);
        try {
            // 增加“字段的当前值” ，并获取“新的当前字段值”
            // add的“参数值”可以为正，也可以为负。
            cal.add(field, r2);            
        } catch (IllegalArgumentException e) {
            // 当field == Calendar.ZONE_OFFSET时，会抛出该异常！
            e.printStackTrace();
        }
        final int add = cal.get(field);



        // 打印字段信息
        System.out.printf("%s:\n\trange is [%d - %d] actualRange is [%d - %d].  original=%d, set(%d)=%d, roll(%d)=%d, add(%d)=%d\n",
               title, min, max, actualMin, actualMax, ori, r1, set, -max, roll, r2, add);
    }

    /**
     * 测试Calendar的“17个字段的公共函数接口”
     *
     * @author skywang (kuiwu-wang@163.com)
     */
    private static void testAllCalendarSections() {
        // 00. ERA 字段
        testSection(Calendar.getInstance(), Calendar.ERA, "Calendar.ERA");
        // 01. YEAR 字段
        testSection(Calendar.getInstance(), Calendar.YEAR, "Calendar.YEAR");
        // 02. MONTH 字段
        testSection(Calendar.getInstance(), Calendar.MONTH, "Calendar.MONTH");
        // 03. WEEK_OF_YEAR 字段
        testSection(Calendar.getInstance(), Calendar.WEEK_OF_YEAR, "Calendar.WEEK_OF_YEAR");
        // 04. WEEK_OF_MONTH 字段
        testSection(Calendar.getInstance(), Calendar.WEEK_OF_MONTH, "Calendar.WEEK_OF_MONTH");
        // 05. DATE 字段
        testSection(Calendar.getInstance(), Calendar.DATE, "Calendar.DATE");
        // 06. DAY_OF_MONTH 字段
        testSection(Calendar.getInstance(), Calendar.DAY_OF_MONTH, "Calendar.DAY_OF_MONTH");
        // 07. DAY_OF_YEAR 字段
        testSection(Calendar.getInstance(), Calendar.DAY_OF_YEAR, "Calendar.DAY_OF_YEAR");
        // 08. DAY_OF_WEEK 字段
        testSection(Calendar.getInstance(), Calendar.DAY_OF_WEEK, "Calendar.DAY_OF_WEEK");
        // 09. DAY_OF_WEEK_IN_MONTH 字段
        testSection(Calendar.getInstance(), Calendar.DAY_OF_WEEK_IN_MONTH, "Calendar.DAY_OF_WEEK_IN_MONTH");
        // 10. AM_PM 字段
        testSection(Calendar.getInstance(), Calendar.AM_PM, "Calendar.AM_PM");
        // 11. HOUR 字段
        testSection(Calendar.getInstance(), Calendar.HOUR, "Calendar.HOUR");
        // 12. HOUR_OF_DAY 字段
        testSection(Calendar.getInstance(), Calendar.HOUR_OF_DAY, "Calendar.HOUR_OF_DAY");
        // 13. MINUTE 字段
        testSection(Calendar.getInstance(), Calendar.MINUTE, "Calendar.MINUTE");
        // 14. SECOND 字段
        testSection(Calendar.getInstance(), Calendar.SECOND, "Calendar.SECOND");
        // 15. MILLISECOND 字段
        testSection(Calendar.getInstance(), Calendar.MILLISECOND, "Calendar.MILLISECOND");
        // 16. ZONE_OFFSET 字段
        testSection(Calendar.getInstance(), Calendar.ZONE_OFFSET, "Calendar.ZONE_OFFSET");
    }

    /**
     * 测试Calendar的“比较接口”
     *
     * @author skywang (kuiwu-wang@163.com)
     */
    private static void testComparatorAPIs() {
        // 新建cal1 ，且时间为1988年
        Calendar cal1 = Calendar.getInstance();
        cal1.set(Calendar.YEAR, 1988);
        // 新建cal2 ，且时间为2000年
        Calendar cal2 = Calendar.getInstance();
        cal2.set(Calendar.YEAR, 2000);
        // 新建cal3, 为cal1的克隆对象
        Calendar cal3 = (Calendar)cal1.clone();

        // equals 判断 cal1和cal2的“时间、时区等”内容是否相等
        boolean isEqual12 = cal1.equals(cal2);
        // equals 判断 cal1和cal3的“时间、时区等”内容是否相等
        boolean isEqual13 = cal1.equals(cal3);
        // cal1是否比cal2早
        boolean isBefore = cal1.before(cal2);
        // cal1是否比cal2晚
        boolean isAfter = cal1.after(cal2);
        // 比较cal1和cal2
        // (01) 若cal1 早于 cal2，返回-1
        // (02) 若cal1 等于 cal2，返回0
        // (03) 若cal1 晚于 cal2，返回1
        int icompare = cal1.compareTo(cal2);

        System.out.printf("\ntestComparatorAPIs: isEuqal12=%s, isEqual13=%s, isBefore=%s, isAfter=%s, icompare=%s\n",
               isEqual12, isEqual13, isBefore, isAfter, icompare);
    }

    /**
     * 测试Calendar的“比较接口”
     *
     * @author skywang (kuiwu-wang@163.com)
     */
    private static void testLenientAPIs() {
            Calendar cal = Calendar.getInstance();

            // 获取默认的“宽容度”。返回true
            boolean oriLenient = cal.isLenient();
            // MONTH值只能是“0-11”，这里越界。但是由于当前cal是宽容的，所以不会抛出异常
            cal.set(Calendar.MONTH, 50);    

            // 设置“宽容度”为false。
            cal.setLenient(false);
            // 获取设置后的“宽容度”
            boolean curLenient = cal.isLenient();
            try {
            // MONTH值只能是“0-11”，这里越界。而且当前cal是不宽容的，所以会产生异常。
            // 但是，异常到下次计算日期时才会抛出。即，set()中不回抛出异常，而要等到get()中才会抛出异常
            cal.set(Calendar.MONTH, 50);
            // 此时，对cal进行读取。读取会导致重新计算cal的值，所以此时抛出异常！
            int m2 = cal.get(Calendar.MONTH);    
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
        }

        System.out.printf("\ntestLenientAPIs: oriLenient=%s, curLenient=%s\n",
               oriLenient, curLenient);
    }

    /**
     * 测试Calendar的Date、TimeZone、MilliSecond等相关函数
     *
     * @author skywang (kuiwu-wang@163.com)
     */
    private static void testTimeAPIs() {
        Calendar cal = Calendar.getInstance();

        // 设置cal的时区为“GMT+8”
        cal.setTimeZone(TimeZone.getTimeZone("GMT+8"));
        // 获取当前的cal时区
        TimeZone timezone = cal.getTimeZone();

        // 设置 milliseconds
        cal.setTimeInMillis(1279419645742l);
        // 获取 milliseconds
        long millis = cal.getTimeInMillis();
        // 设置 milliseconds之后，时间也改变了。
        // 获取cal对应的日期
        Date date = cal.getTime();

        // 设置时间为“1988-08-08”
        cal.set(1988, 08, 08);
        // 设置时间为“1999-09-09 09:09”
        cal.set(1999, 09, 09, 9, 9);
        // 设置时间为“2000-10-10 10:10:10”
        cal.set(2000, 10, 10, 10, 10, 10);

        System.out.printf("\ntestTimeAPIs: date=%s, timezone=%s, millis=%s\n",
               date, timezone, millis);
    }

    /**
     * 测试Calendar的clone()，getFirstDayOfWeek()等接口
     *
     * @author skywang (kuiwu-wang@163.com)
     */
    private static void testOtherAPIs() {
        Calendar cal = Calendar.getInstance();
        // 克隆cal
        Calendar clone = (Calendar)cal.clone();

        // 设置 为 2013-01-10。 
        // 注：2013-01-01 为“星期二”，2013-01-06为“星期天”，
        clone.set(Calendar.YEAR, 2013);
        clone.set(Calendar.MONTH, 0);
        clone.set(Calendar.DATE, 10);
        // 设置“本年的第一个星期最少包含1天”。
        // 则2013-01-10属于第2个星期
        clone.setMinimalDaysInFirstWeek(1);
        int m1 = clone.getMinimalDaysInFirstWeek();
        int index1 = clone.get(Calendar.WEEK_OF_YEAR);

        // 设置“本年的第一个星期最少包含7天”。
        // 则2013-01-10属于第1个星期
        clone.setMinimalDaysInFirstWeek(7);
        int m2 = clone.getMinimalDaysInFirstWeek();
        int index2 = clone.get(Calendar.WEEK_OF_YEAR);

        // 设置“每周的第一天是星期几”。
        clone.setFirstDayOfWeek(Calendar.WEDNESDAY);
        // 获取“每周的第一天是星期几”。
        int firstdayOfWeek = clone.getFirstDayOfWeek();

        System.out.printf("\ntestOtherAPIs: firstdayOfWeek=%s, [minimalDay, WeekOfYear]={(%s, %s), (%s, %s)} %s\n",
               firstdayOfWeek, m1, index1, m2, index2, clone.getTime());
    }
}
```

## 问题
1. 获取当前时间有几种方式？

答：获取当前时间常见的方式有以下三种：

```
new Date()
Calendar.getInstance().getTime()
LocalDateTime.now()
```

2. 如何获取昨天此刻的时间？

答：以下为获取昨天此刻时间的两种方式：


```
// 获取昨天此刻的时间（JDK 8 以前）
Calendar c = Calendar.getInstance();
c.add(Calendar.DATE,-1);
System.out.println(c.getTime());
// 获取昨天此刻的时间（JDK 8）
LocalDateTime todayTime = LocalDateTime.now();
System.out.println(todayTime.plusDays(-1));
```

3. 如何获取本月的最后一天？

答：以下为获取本月最后一天的两种方式：


```
// 获取本月的最后一天（JDK 8 以前）
Calendar ca = Calendar.getInstance();
ca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));
System.out.println(ca.getTime());
// 获取本月的最后一天（JDK 8）
LocalDate today = LocalDate.now();
System.out.println(today.with(TemporalAdjusters.lastDayOfMonth()));
```

4. 获取当前时间的时间戳有几种方式？

答：以下为获取当前时间戳的几种方式：


```
System.currentTimeMillis()
new Date().getTime()
Calendar.getInstance().getTime().getTime()
Instant.now().toEpochMilli()
LocalDateTime.now().toInstant(ZoneOffset.of("+8")).toEpochMilli()
其中，第四种和第五种方式是 JDK 8 才新加的。
```


5. 如何优雅地计算两个时间的相隔时间？

答：JDK 8 中可以使用 Duration 类来优雅地计算两个时间的相隔时间，代码如下：


```
LocalDateTime dt1 = LocalDateTime.now();
LocalDateTime dt2 = dt1.plusSeconds(60);
Duration duration = Duration.between(dt1, dt2);
System.out.println(duration.getSeconds());  // output:60
```

6. 如何优雅地计算两个日期的相隔日期？

答：JDK 8 中可以使用 Period 类来优雅地计算两个日期的相隔日期，代码如下：

```
LocalDate d1 = LocalDate.now();
LocalDate d2 = d1.plusDays(2);
Period period = Period.between(d1, d2);
System.out.println(period.getDays());   //output:2
```

7. SimpleDateFormat 是线程安全的吗？为什么？

答：SimpleDateFormat 是非线程安全的。因为查看 SimpleDateFormat 的源码可以得知，所有的格式化和解析，都需要通过一个中间对象进行转换，这个中间对象就是 Calendar，这样的话就造成非线程安全。试想一下当我们有多个线程操作同一个 Calendar 的时候后来的线程会覆盖先来线程的数据，那最后其实返回的是后来线程的数据，因此 SimpleDateFormat 就成为了非线程的了。

8. 怎么保证 SimpleDateFormat 的线程安全？

答：保证 SimpleDateFormat 线程安全的方式如下：

使用 Synchronized，在需要时间格式化的操作使用 Synchronized 关键字进行包装，保证线程堵塞格式化；
手动加锁，把需要格式化时间的代码，写到加锁部分，相对 Synchronized 来说，编码效率更低，性能略好，代码风险较大（风险在于不要忘记在操作的最后，手动释放锁）；
使用 JDK 8 的 DateTimeFormatter 替代 SimpleDateFormat。


9. JDK 8 中新增的时间类都有哪些优点？

答：JDK 8 中的优点具体有以下几个优点，如下：

1. 线程安全性
1. 使用的便利性（如获取当前时间戳的便利性、增减日期的便利性等）
1. 编写代码更简单优雅，如当前时间的格式化：LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));


10. 如何比较两个时间（Date）的大小？

答：时间比较有以下三种方式：

1. 获取两个时间的时间戳，得到两个 long 类型的变量，两个变量相减，通过结果的正负值来判断大小；
1. 通过 Date 自带的 before()、after()、equals() 等方法比较，代码示例 date1.before(date2)；
1. 通过 compareTo() 方法比较，代码示例：date1.compareTo(date2)，返回值 -1 表示前一个时间比后一个时间小，0 表示两个时间相等，1 表示前一个时间大于后一个时间。

