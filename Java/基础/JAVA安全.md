


这个问题可能有点宽泛，我们可以用特定类型的安全风险为例，如拒绝服务（DoS）攻击，分析 Java 开发者需要重点考虑的点。

```
sql注入
IO流没有关闭
不安全的Random
重定向URL 安全合法性
上传文件做大小监测
发射访问私有变量
日志有敏感信息
HTTP请求包括除了post和get以外的请求
```

```、
//sql注入
'’or 1 = 1 -- and password='’
"or "a"="a
admin' or '1'='1
' or ''='
 ')or('a'='a
or 1=1--
'or 1=1--
a'or' 1=1--
"or 1=1--
'or'a'='a
"or"="a'='a
'or''='
'or'='or'
1 or '1'='1'=1
1 or '1'='1' or 1=1
 'OR 1=1%00

//解决
（简单又有效的方法）PreparedStatement
使用正则表达式过滤传入的参数
字符串过滤（mybatis）
jsp中调用该函数检查是否包函非法字符
JSP页面判断代码

//解决
总结就是： 
1.判断是否包含--
2.判断是否包含;
3.判断是否包含恒等式
4.其他特殊的，例如不能含有or=
```

```
XML注入，XML保存和展示之前，对数据部分，单独做转义即可：
```

DoS 是一种常见的网络攻击，有人也称其为“洪水攻击”。最常见的表现是，**利用大量机器发送请求，将目标网站的带宽或者其他资源耗尽，导致其无法响应正常用户的请求**。

我认为，从 Java 语言的角度，更加需要重视的是程序级别的攻击，也就是利用 Java、JVM 或应用程序的瑕疵，进行低成本的 DoS 攻击，这也是想要写出安全的 Java 代码所必须考虑的。例如：

- 如果使用的是早期的 JDK 和 Applet 等技术，攻击者构建合法但恶劣的程序就相对容易，例如，将其线程优先级设置为最高，做一些看起来无害但空耗资源的事情。幸运的是类似技术已经逐步退出历史舞台，在 JDK 9 以后，相关模块就已经被移除。
- 上一讲中提到的哈希碰撞攻击，就是个典型的例子，对方可以轻易消耗系统有限的 CPU 和线程资源。从这个角度思考，类似加密、解密、图形处理等计算密集型任务，都要防范被恶意滥用，以免攻击者通过直接调用或者间接触发方式，消耗系统资源。
- 利用 Java 构建类似上传文件或者其他接受输入的服务，需要对消耗系统内存或存储的上限有所控制，因为我们不能将系统安全依赖于用户的合理使用。其中特别注意的是涉及解压缩功能时，就需要防范Zip bomb等特定攻击。
- 另外，Java 程序中需要明确释放的资源有很多种，比如文件描述符、数据库连接，甚至是再入锁，任何情况下都应该保证资源释放成功，否则即使平时能够正常运行，也可能被攻击者利用而耗尽某类资源，这也算是可能的 DoS 攻击来源。

## 定位问题
1. 问题可能来自于 Java 服务自身，也可能仅仅是受系统里其他服务的影响。初始判断可以先确认是否出现了意外的程序错误，例如检查应用本身的错误日志。
1. 对于分布式系统，很多公司都会实现更加系统的日志、性能等监控系统。一些 Java 诊断工具也可以用于这个诊断，例如通过 JFR（Java Flight Recordera>），监控应用是否大量出现了某种类型的异常。
    1. 如果有，那么异常可能就是个突破点。
    1. 如果没有，可以先检查系统级别的资源等情况，监控 CPU、内存等资源是否被其他进程大量占用，并且这种占用是否不符合系统正常运行状况。
1. 监控 Java 服务自身，例如 GC 日志里面是否观察到 Full GC 等恶劣情况出现，或者是否 Minor GC 在变长等；利用 jstat 等工具，获取内存使用的统计信息也是个常用手段；利用 jstack 等工具检查是否出现死锁等。
1. 如果还不能确定具体问题，对应用进行 Profiling 也是个办法，但因为它会对系统产生侵入性，如果不是非常必要，大多数情况下并不建议在生产系统进行。
1. 定位了程序错误或者 JVM 配置的问题后，就可以采取相应的补救措施，然后验证是否解决，否则还需要重复上面部分过程。

找出耗费CPU资源的Java线程
- ==利用 top 命令获取相应 pid==，“-H”代表 thread 模式，你可以配合 grep 命令更精准定位。
- ==最后利用 jstack 获取的线程==，对比相应的 ID 即可。
当然，还有更加通用的诊断方向，利用 vmstat 之类，查看上下文切换的数量，比如下面就是指定时间间隔为 1，收集 10 次

- top -h , 再jstack， 再换算tid比较累，而且jstack会造成停顿。推荐用vjtools里的vjtop, 不断显示繁忙的javaj线程，不造成停顿。

IO和内存：
- ==利用 free 之类查看内存使用。==
- 或者，进一步判断 swap 使用情况，==top 命令输出中 Virt 作为虚拟内存使用量==，就是物理内存（Res）和 swap 求和，所以可以反推 swap 使用。显然，JVM 是不希望发生大量的 swap 使用的。
- 对于 IO 问题，既可能发生在磁盘 IO，也可能是网络 IO。例如，==利用 iostat 等命令有助于判断磁盘的健康状况==。我曾经帮助诊断过 Java 服务部署在国内的某云厂商机器上，其原因就是 IO 表现较差，拖累了整体性能，解决办法就是申请替换了机器。





对于JVM 层面的性能分析，我们已经介绍过非常多了：

1. Jstat是JDK自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool”，它位于java的bin目录下，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。
1. 利用 JMC、JConsole 等工具进行运行时监控。
1. 利用各种工具，在运行时进行堆转储分析，或者获取各种角度的统计数据（如jstat -gcutil 分析 GC、内存分带等）。
1. GC 日志等手段，诊断 Full GC、Minor GC，或者引用堆积等。



- ==“dstat命令是一个用来替换vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具，是一个全能系统信息统计工具”==

### Java代码注意点
1 数值防范溢出
```
if(a+b<c)
改成
if(a<c-b)
//数值类型需要防范溢出
```

2 数据库账号密码最起码用MD5加密加盐值，而不是明文

3 不要将敏感信息放到异常处理抛出中

4 敏感信息不要序列化，加transient

5 反序列化也要安全检查和数据监测





