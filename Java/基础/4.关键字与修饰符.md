[toc]





# 关键字



## final 关键字

>final关键字主要用在三个地方：变量、方法、类。

1. 对于一个final变量：
   - 对于基本类型，final 使数值不变；
   - 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

```
final int x = 1;
// x = 2;  // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1;
```

2. 当用final修饰一个类时，==表明这个类不能被继承。== final类中的所有成员方法都会被隐式地指定为final方法。 而且final修饰的类，他不会从虚表中查询，而是从类中直接拿取，速度快。

3. 使用final方法的原因有两个。
   - 第一个原因是把方法锁定，以防任何继承类修改它的含义；
   - 第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。

### 不变类

不变类的意思是创建该类的实例后，该实例的实例变量是不可改变的。满足以下条件则可以成为不可变类：

1. 使用private和final修饰符来修饰该类的成员变量
2. 提供带参的构造器用于初始化类的成员变量；
3. 仅为该类的成员变量提供getter方法，不提供setter方法，因为普通方法无法修改fina修饰的成员变量；
4. 如果有必要就重写Object类 的hashCode()和equals()方法，应该保证用equals()判断相同的两个对象其Hashcode值也是相等的。

### final和非final的性能：

- 对于是否有 final 修饰的方法，对性能的影响可以忽略不计。因为它们生成的字节码除了 flags 标志位是否有 final 修饰不同之外，其他所有的JVM指令，都是一样的（对于方法本身，以及调用者本身的字节码都一样）。对于JVM来说，它执行的就是字节码，如果字节码都一样的话，那对于JVM来说，它就是同一样东西的了。使用 final ，更多的应该是根据Java对 final 的语义来定义，而不是只想着为了提升性能（而且这影响可以忽略不计）而刻意用 final.

- （网上认为 final 比非 final 快，就是认为它是在编译的时候已经静态绑定了，不需要在运行时再动态绑定。这个可能以前的JVM上是正确的，但在现代的JVM上，这个可以认为没什么影响）

### 安全发布

```
比如 Object o = new Object(); 然后接下来使用对象o。

但是对于普通变量的创建，之前分析过，大致分为三个步骤：
1.分配内存空间
2.将o指向分配的内存空间
3.调用构造函数来初始化对象
这三个步骤不是原子的，如果执行到第二步(还没有进行初始化)，此时对象已经不是null了，这时候如果被其他代码访问，这将收获一个错误的结果。

```

>怎么保障安全发布？有几种方法：

1. 一种是的锁机制，通过加锁可以保障中间状态不会被读取
2. 借助于volatile或者AtomicReference声明对象
3. 借助于final关键字
4. 在静态初始化块中，进行初始化（JVM会保障）

#### final与安全发布

>Final 变量在并发当中，原理是通过禁止cpu的指令集重排序，来保证对象的安全发布，防止对象引用被其他线程在对象被完全构造完成前拿到并使用。即：对于final，当你创建一个对象时，使用final关键字能够使得另一个线程不会访问到处于“部分创建”的对象

1. 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
   。
    - 写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：
      JMM禁止编译器把final域的写重排序到构造函数之外；
      编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。

    - 写final域的重排序规则可以确保：++在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，**而普通域就不具有这个保障**++。

2. 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序
   -  读final域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。


```
public class FinalDemo {
    private int a;  //普通域
    private final int b; //final域
    private static FinalDemo finalDemo;

    public FinalDemo() {
        a = 1; // 1. 写普通域
        b = 2; // 2. 写final域
    }

    public static void writer() {
        finalDemo = new FinalDemo();
    }

    public static void reader() {
        FinalDemo demo = finalDemo; // 3.读对象引用
        int a = demo.a;    //4.读普通域
        int b = demo.b;    //5.读final域
    }
}
//写 
a,b之间没有数据依赖性，普通域（普通变量）a可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量a初始化之前的值（零值），这样就可能出现错误。
而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程B就能够读到final变量初始化后的值。
//读
读对象的普通域被重排序到了读对象引用的前面就会出现线程B还未读到对象引用就在读取该对象的普通域变量，
这显然是错误的操作。而final域的读操作就“限定”了在读final域变量前已经读到了该对象的引用，从而就可以避免这种情况
```


### final的特点

```
在final定义的方法里，不是必须要用 final 定义变量。
final 定义的变量，可以在在定义的同时完成初始化，也可以在构造方法中完成初始化。
final 修饰方法，不能被子类重写，但是可以被重载。
final 定义变量，可以用 static 修饰。

public class FinalTest {

    private final int t1 = 1;
    private final String t2;
    private final static  String t3;
   
     public final void setT2(){
       // t2 = 4;//不可以 ，只能够在构造函数里赋值
    }  
    public final void setT2(final int a){ //final方法可以重载，不可以重写
       
        //a=3;//不可以 因为调用方法的时候 a已经被定义了不可以改
    }  
    public FinalTest(String t2) {
        this.t2 = t2; //final没有赋值可以在构造函数中执行
      
      //  t1 = 1;//不可以，因为已经赋值，只能赋值一次
    }  
    static {
        t3 = "hello"; //静态方法快中只能初始化静态变量，不管是否为final
       // t2 = "hello";//不可以 因为t2不是静态变量 
    }
    
    private final static Person person = new Person(24, 170);
    
    
    
    
    public static void main(String[] args) {
        //对final引用数据类型person进行更改成功
        //过这个实验我们就可以看出来当final修饰基本数据类型变量时，不能对基本数据类型变量重新赋值，因此基本数据类型变量不能被改变。
        //而对于引用类型变量而言，它仅仅保存的是一个引用，final只保证这个引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个对象属性是可以改变的。
        
        person.age = 22;//可以修改内容 
        //person = new Person(1,10); //不可以 final不能重新指向新的对象
        System.out.println(person.toString());
    }
    
    
    static class Person {
        private int age;
        private int height;
    
        public Person(int age, int height) {
            this.age = age;
            this.height = height;
        }
    }

    
}

```




## static 关键字

>static 关键字主要有以下四种使用场景：

1. ++修饰成员变量和成员方法++: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：`类名.静态变量名`    `类名.静态方法名()`
2. ++静态代码块++:静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.

3. ++静态内部类++（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。

4. ++静态导包++(用来导入类中的静态资源，1.5之后的新特性):

```
在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。

import static com.xxx.ClassName.*
```

5. 初始化顺序

   静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。

```
public static String staticField = "静态变量";
static {
    System.out.println("静态语句块");
}
public String field = "实例变量";
{
    System.out.println("普通语句块");
}
最后才是构造函数的初始化。

public InitialOrderTest() {
    System.out.println("构造函数");
}
```

```
存在继承的情况下，初始化顺序为：

父类（静态变量、静态语句块）
子类（静态变量、静态语句块）
父类（实例变量、普通语句块）
父类（构造函数）
子类（实例变量、普通语句块）
子类（构造函数）
```


### 修饰成员变量(常用)

> 静态变量被所有的对象所共享，内存中只有一个实例，当类被加载，就会为该静态变量分配内存空间，跟 class 本身在一起存放在方法区中。而且它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。

1. 静态变量在内存中只有1个拷贝：JVM只为静态分配1次内存
   - a. 全部对象共用这个static关键字修饰的成员变量，方便对象间共享，节省内存
   - b. 未被Static修饰的成员变量 = 实例变量：每创建1个实例，JVM就会为实例变量分配1次内存，实例变量在内存中可以有多个拷贝（但互相不影响，更加灵活）
 2. 可用类名直接访问：在加载类的过程中完成静态变量的内存分配，（也可通过对象实例访问）
    （属于类，不属于实例）
3. 非线程安全：因静态变量被类的所有实例共用
4. 局部变量也能被声明为static


### 修饰方法

>静态方法和非静态方法一样，都跟class 本身在一起存放在内存中，永远不会被回收，除非 JVM 退出，他们使用的区别的一个方面是非static方法需要实例调用，static方法直接用类名调用；在静态方法中不能访问非静态成员方法和变量，但是在非静态成员方法中是可以访问静态成员方法/变量的

    1. 可直接通过类名调用，也可通过对象实例调用
       - （属于类，不属于实例）
   2. 任何的实例都可调用（方便共享、公用）
   3. 只能访问所属类的静态成员变量 & 方法、不能使用this、super关键字
      - （this = 调用该函数的对象、但由于静态方法可以直接使用类名调用（即可能还没创建对象），所以不可使用this）


### 方法和变量调用格式：

- 类名.静态变量名
- 类名.静态方法名()
- 如果变量或者方法被 private 则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。


```java
public class StaticBean {

    String name;
    静态变量
    static int age;

    public StaticBean(String name) {
        this.name = name;
    }
    //静态方法
    static void SayHello() {
        System.out.println(Hello i am java);
    }
    @Override
    public String toString() {
        return StaticBean{ +
                name=' + name + ''' + age + age +
                '}';
    }
}

public class StaticDemo {

    public static void main(String[] args) {
        StaticBean a = new StaticBean(1);
        a.age;
        StaticBean.age;//直接使用
        StaticBean.SayHello;//直接使用
    }

}
```


### 静态代码块

>所谓代码块是指使用“{}”括起来的一段代码。其中静态代码块只执行一次，构造代码块在每次创建对象是都会执行。根据位置不同，代码块可以分为四种：普通代码块、构造块、静态代码块、同步代码块。因为JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配。所以实际工作中我们可以使用静态代码块初始化一些不变的属性。 


静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。 该类不管创建多少对象，静态代码块只执行一次.

```
//静态代码块的格式是 
static {    
    语句体;   
}
```


一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。


```
/**
 * 1. 代码块 使用 Static修饰
 * 2. 静态块只会在类加载到内存中时执行1次
 *    a. 若有多个static代码块，JVM将按照它们在类中出现的先后顺序依次执行
 *    b. 静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量可以赋值，但不能访问。如下实例所示
 */

 public class Test { 

     // 使用静态修饰的静态代码块
     static{ 
         i=0;  // 給变量赋值，可通过编译 
         System.out.print(i); // 非法， 提示：“非法向前引用” 
     } 

     static int i=1; 
  
 }
```

#### static静态代码块与非静态代码块(构造代码块)

- 相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。 

- 不同点： 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。 

>一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法, 两者的区别是 静态代码块是自动执行的而静态方法是被调用的时候才执行的. 



```java
public class Test {
    public Test() {
        System.out.print(默认构造方法！--);
    }

     非静态代码块
    {
        System.out.print(非静态代码块！--);
    }
     静态代码块
    static {
        System.out.print(静态代码块！--);
    }

    public static void test() {
        System.out.print(静态方法中的内容! --);
        {
            System.out.print(静态方法中的代码块！--);
        }

    }
    public static void main(String[] args) {

        Test test = new Test();   
        Test.test();静态代码块！--静态方法中的内容! --静态方法中的代码块！--
    }
```

当执行 `Test.test();` 时输出：

```
静态代码块！--静态方法中的内容! --静态方法中的代码块！--
```

当执行 `Test test = new Test();` 时输出：

```
静态代码块！--非静态代码块！--默认构造方法！--
```


非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。 



### 静态内部类

>静态内部类，该类独立存在，形式上与外部类有内外关系，实际上则没有，本质是为了隐藏自身。

1. 加载一个类时，其内部类不会同时被加载。
2. 一个类被加载时刻 = 当且仅当其某个静态成员被调用时（静态域、构造器、静态方法等）


静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：

1.  它的创建是不需要依赖外围类的创建。
2.  它不能使用任何外围类的非static成员变量和方法。



```java
//Example（静态内部类实现单例模式）
public class Singleton {
    
    声明为 private 避免调用默认构造方法创建对象
    private Singleton() {
    }
    
    声明为 private 表明静态内部该类只能在该 Singleton 类中被访问
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

>当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 `getUniqueInstance() `方法从而触发 `SingletonHolder.INSTANCE` 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。

这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。

### 静态导包

>将类的方法直接导入到当前类中，从而直接使用“方法名”即可调用类方法，更加方便。静态导入是JKD1.5后新加的功能，一般不怎么常用，了解即可。有时候面试答出来这个会让别的觉得你热爱技术。


```
格式为：import static
```


这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法


```java
  //Math. --- 将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用
  //如果只想导入单一某个静态方法，只需要将换成对应的方法名即可
 
import static java.lang.Math.*;

  //换成import static java.lang.Math.max;具有一样的效果
 
public class Demo {
  public static void main(String[] args) {
 
    int max = max(1,2);//Math.max(1,2);
    System.out.println(max);
  }
}

```

### static只能访问静态

>在静态方法中是没有this关键字的如何理解呢?

- 静态是随着类的加载而加载，this是随着对象的创建而存在。
- 静态比对象先存在。
       

>静态方法只能访问静态的成员变量和静态的成员方法

- 静态方法：
  - 成员变量：只能访问静态变量
  - 成员方法：只能访问静态成员方法
- 非静态方法：
  - 成员变量：可以是静态的，也可以是非静态的
  - 成员方法：可是是静态的成员方法，也可以是非静态的成员方法。
          


### static缺陷：

> Static确实是存在诸多的作用，但是它也存在一些缺陷。

1. 它只能调用static变量。
2. 它只能调用static方法。
3. static是不允许用来修饰局部变量
4. 不能以任何形式引用this、super。
5. static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。




### 静态方法与非静态方法

静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。



```java
//Example
class Foo {
    int i;
    public Foo(int i) { 
       this.i = i;
    }

    public static String method1() {
       return An example string that doesn't depend on i (an instance variable);
       
    }

    public int method2() {
       return this.i + 1;  Depends on i
    }

}
```

你可以像这样调用静态方法：`Foo.method1（）`。 如果您尝试使用这种方法调用 method2 将失败。 但这样可行：`Foo bar = new Foo（1）;bar.method2（）;`

总结：

- 在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 
- 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制 

### static执行顺序

被static修饰的成员将最优先加载到内存里，静态代码块内容先执行，接着执行父类非静态代码块和构造方法，然后执行子类非静态代码块和构造方法。

静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。

>父类的（静态变量、静态初始化块）=> 子类的（静态变量、静态初始化块）=> 父类的（变量、初始化块、构造器）=> 子类的（变量、初始化块、构造器）




## this 关键字

this关键字用于引用类的当前实例。 例如：

```java
class Manager {
    Employees[] employees;
     
    void manageEmployees() {
        int totalEmp = this.employees.length;
        System.out.println("Total employees: " + totalEmp);
        this.report();
    }
     
    void report() { }
}
```

在上面的示例中，this关键字用于两个地方：

- this.employees.length：访问类Manager的当前实例的变量。
- this.report（）：调用类Manager的当前实例的方法。

此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。



## super 关键字

super关键字用于从子类访问父类的变量和方法。 例如：

```java
public class Super {
    Super(){
        
    }
    protected int number;
     
    protected showNumber() {
        System.out.println("number = " + number);
    }
}
 
public class Sub extends Super {
    Sub(){
        super();//构造函数需要super置于前
        //...
    }
    void bar() {
        super.number = 10;
        super.showNumber();
    }
}
```

==super在构造函数中要放在第一位！==


在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 `showNumber（）` 方法。

**使用 this 和 super 要注意的问题：**

- 在构造器中使用 `super（）` 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
- this、super不能用在static方法中。

**简单解释一下：**

被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， **this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西**。

## assert

断言，用于软件调试，在代码中进行进行boolean判断检查：1.检查控制流  2.检查输入参数 3.检查函数有效 4.检查长须不变量...

```
Class Test{
    public static void main(String[] args){
        assert 1+1 == 2;
        assert 2+3 ==1;
    }
}

//执行java Test 没问题，但是java -ea Test的时候报错
```



# **修饰符**

修饰符：

1. 访问权限修饰符
2. 非访问权限修饰符
3. 方法变量修饰符
4. 类修饰符

Java语言提供了很多修饰符，大概分为两类： 

1. 访问权限修饰符 
   - public：共有访问。对所有的类都可见。
   - protected：保护型访问。对同一个包可见，对不同的包的子类可见。
   - default：默认访问权限。只对同一个包可见，注意对不同的包的子类不可见。
   - private：私有访问。只对同一个类可见，其余都不见。

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/xiushifu.png) 

2. 非访问权限修饰符

   - static 修饰符，用来创建类方法和类变量。
   - final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。
   - abstract 修饰符，用来创建抽象类和抽象方法。
   - synchronized 用于多线程的同步。
   - volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。
   - transient：序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。

## 按照修饰类型分类

### 方法变量修饰符

方法修饰符

- public（公共控制符），包外包内都可以调用该方法。
- protected（保护访问控制符）指定该方法可以被它的类和子类进行访问。
- default(默认权限），指定该方法只对同包可见，对不同包（含不同包的子类）不可见。
- private（私有控制符）指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类），非常严格的控制。
- final ,指定方法已完备，不能再进行继承扩充。
- static，指定不需要实例化就可以激活的一个方法，即在内存中只有一份，通过类名即可调用。
- synchronize，同步修饰符，在多个线程中，该修饰符用于在运行前，对它所属的方法加锁，以防止其他线程的访问，运行结束后解锁。
- native，本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。
- abstract ,抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾，例如：public abstract sample();。

### 成员变量修饰符

- public（公共访问控制符），指定该变量为公共的，它可以被任何对象的方法访问。
- protected（保护访问控制符）指定该变量可以别被自己的类和子类访问。在子类中可以覆盖此变量。
- default(默认权限），指定该变量只对同包可见，对不同包（含不同包的子类）不可见。
- private（私有访问控制符）指定该变量只允许自己的类的方法访问，其他任何类（包括子类）中的方法均不能访问。
- final，最终修饰符，指定此变量的值不能变。
- static（静态修饰符）指定变量被所有对象共享，即所有实例都可以使用该变量。变量属于这个类。
- transient（过度修饰符）指定该变量是系统保留，暂无特别作用的临时性变量。不持久化。
- volatile（易失修饰符）指定该变量可以同时被几个线程控制和修改，保证两个不同的线程总是看到某个成员变量的同一个值。 
- final 和 static 经常一起使用来创建常量。

### 局部变量修饰符

only ++final++ is permitted。 

>为什么不能赋予权限修饰符？ 

因为局部变量的生命周期为一个方法的调用期间，所以没必要为其设置权限访问字段，既然你都能访问到这个方法，所以就没必要再为其方法内变量赋予访问权限，因为该变量在方法调用期间已经被加载进了虚拟机栈，换句话说就是肯定能被当前线程访问到，所以设置没意义。 

>为什么不能用static修饰 
>我们都知道静态变量在方法之前先加载的，所以如果在方法内设置静态变量，可想而知，方法都没加载，你能加载成功方法内的静态变量？




### 类修饰符


- 接口修饰符只能用public、default和abstract。 不能用final、static修饰。

- 接口默认修饰为abstract。
  接口中方法修饰符

```
only public & abstract are permitted 。
```


意思只能用 public abstract修饰，当然如果你什么都不写，默认就是public abstract。 
注意：在Java1.8之后，接口允许定义static 静态方法了！所以也可以用static来修饰！

### 外部类修饰符

- public（访问控制符），将一个类声明为公共类，它可以被任何对象访问，一个程序的主类必须是公共类。
- default（访问控制符），类只对包内可见，包外不可见。
- abstract（非访问控制符），将一个类声明为抽象类，抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充，抽象类可以包含抽象方法和非抽象方法。。
- final（非访问控制符），将一个类生命为最终（即非继承类），表示它不能被其他类继承。 

>注意： 

1. protected 和 private 不能修饰外部类，是因为外部类放在包中，只有两种可能，包可见和包不可见。 
2. final 和 abstract不能同时修饰外部类，因为该类要么能被继承要么不能被继承，二者只能选其一。 
3. 不能用static修饰类，因为类加载后才会加载静态成员变量。所以不能用static修饰类和接口，因为类还没加载，无法使用static关键字。

### 内部类修饰符

内部类与成员变量地位一直，所以可以public,protected、default和private，同时还可以用static修饰，表示嵌套内部类，不用实例化外部类，即可调用。



