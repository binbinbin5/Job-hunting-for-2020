[toc]
# 运算符顺序


```
单目乘除为关系，逻辑三目后赋值。 

单目：单目运算符+ –(负数) ++ -- 等 
乘除：算数单目运算符* / % + - 
为：位移单目运算符<< >> 
关系：关系单目运算符> < >= <= == != 
逻辑：逻辑单目运算符&& || & | ^ 
三目：三目单目运算符A > B ? X : Y 
后：无意义，仅仅为了凑字数 
赋值：赋值=
```

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/%E4%BA%91%E7%AE%97%E6%B3%95.jpeg)

## 短路效应

在Java中逻辑运算符&& 和 ||，它们都存在短路效应。

1. 对于a && b，只有当a和b同时为true时，整个表达式才为true（在java中，首先运算表达式a，如果a为true，则继续运算表达式b，只有a 和 b同时为true，结果才是true）（如果表达式a为false，那么整个表达式也肯定为false,所以表达式b不会被运算）
2. 对于a || b，只有当a和b同时为false时，整个表达式才为false（有一个为true,则表达式为true）（如果a为true,整个表达式的值为true，则没有必要再运算表达式b）


```
if(a && b){
    // 如果a是false,b直接不运算 
}

if(a || b){
    //如果a是true，b直接不运算
}
```

## 符号说明

### a++ 和 ++a


```
int a = 1;
int b = 1;
for(int i = 0;i<100;i++){
    a = a++;
    b = ++b;
}

//最后 a的结果是 1， b的结果是101

a = a++ 的操作是 ，先执行 a = a ，再执行 a++，所以a一直是1
b = ++b 的操作是 ，先执行 ++b，在执行 b = b ,所以b会一直增加

a = 1;
b = 2;

a+++++b = ?

a++还是1，++b是3，所以 a+++++b = 4 ;

```







### | & ^

1. |(或) 参加运算的两个数，换算为二进制(0、1)后，进行或运算。只要相应位上存在1，那么该位就取1，均不为1，即为0。（有1就1，其他为0）
2. &(与) 参加运算的两个数，换算为二进制(0、1)后，进行与运算。只有当相应位上的数都是1时，该位才取1，否则该为为0。（全1才1，其他为0）
3. ^(异或) 参加运算的两个数，换算为二进制(0、1)后，进行异或运算。只有当相应位上的数字不相同时，该为才取1，若相同，即为0。（相同都0，不同为1）
4. 取反(~):参加运算的两个数，换算为二进制(0、1)后，进行取反运算。每个位上都取相反值，1变成0，0变成1。

### >>  >>> << <<<



```
//>> 与 >>> 区别
>> 在执行右移操作的时候，若参与的数为正，高位补0，若为负，高位补1
>>> 在执行右移操作的时候，无论正负，都补0
```





```
//无符号右移运算符>>> 只是对32位和64位的值有意义
System.out.println(8>>1);//4
System.out.println(8>>2);//2
System.out.println(8>>3);//1
System.out.println(-8>>1);//-4
System.out.println(-8>>2);//-2
System.out.println(-8>>3);//-1
System.out.println(8<<1);//16
System.out.println(8<<2);//32
System.out.println(8<<3);//64
System.out.println(-8<<1);//-16
System.out.println(-8<<2);//-32
System.out.println(-8<<3);//-64
```



1. 左移(<<):参加运算的两个数，换算为二进制(0、1)后，进行左移运算，用来将一个数各二进制位全部向左移动若干位。

```
对10左移2位(就相当于在右边加2个0)：
0000 0000 0000 1010
--------------------
0000 0000 0010 1000
所以：10 << 2 = 0000 0000 0010 1000 = 40
```

2. 右移(>>):参加运算的两个数，换算为二进制(0、1)后，进行右移运算，用来将一个数各二进制位全部向右移动若干位。


```
对10右移2位(就相当于在左边加2个0)：
0000 0000 0000 1010
--------------------
0000 0000 0000 0010
所以：10 >> 2 = 0000 0000 0000 0010 = 2
```

3. 无符号左移（<<<）

4. 无符号右移（>>>）

## 符号用处

### 判断奇偶数

判断一个数是基于还是偶数，相信很多人都做过，一般的做法的代码如下

```
if( n % 2) == 01
    // n 是个奇数
}
```


如果把 n 以二进制的形式展示的话，++其实我们只需要判断最后一个二进制位是 1 还是 0 就行了，如果是 1 的话，代表是奇数，如果是 0++ 则代表是偶数，所以采用位运算的方式的话，代码如下：

```
if(n & 1 == 1){
    // n 是个奇数。
}
```

有人可能会说，我们写成 n % 2 的形式，编译器也会自动帮我们优化成位运算啊，这个确实，有些编译器确实会自动帮我们优化。但是，我们自己能够采用位运算的形式写出来，当然更好了。当然，时间效率也快很多。

### 交换两个数

交换两个数每次都会使用一个额外来变量来辅助交换，例如，我们要交换 x 与 y 值，传统代码如下：

```
int tmp = x;
x = y;
y = tmp;
```


这样写有问题吗？没问题，通俗易懂，万一哪天有人要为难你，不允许你使用额外的辅助变量来完成交换呢？你还别说，有人面试确实被问过，这个时候，位运算大法就来了。代码如下：

```
x = x ^ y   // （1）
y = x ^ y   // （2）
x = x ^ y   // （3）
```


在此解释下，我们知道，两个相同的数异或之后结果会等于 0，即 n ^ n = 0。并且任何数与 0 异或等于它本身，即 n ^ 0 = n。所以，解释如下：
把（1）中的 x 带入 （2）中的 x，有

```
y = x^y = (x^y)^y = x^(y^y) = x^0 = x
```

 x 的值成功赋给了 y。
对于（3）,推导如下：

```
x = x^y = (x^y)^x = (x^x)^y = 0^y = y。
```

这里解释一下，异或运算支持运算的交换律和结合律哦。

### 找出没有重复的数

给你一组整型数据，这些数据中，其中有一个数只出现了一次，其他的数都出现了两次，让你来找出一个数 。
这道题可能很多人会用一个哈希表来存储，每次存储的时候，记录 某个数出现的次数，最后再遍历哈希表，看看哪个数只出现了一次。这种方法的时间复杂度为 O(n)，空间复杂度也为 O(n)了。
然而我想告诉你的是，采用位运算来做，绝对高逼格！
我们刚才说过，两个相同的数异或的结果是 0，一个数和 0 异或的结果是它本身，所以我们把这一组整型全部异或一下，例如这组数据是：1，  2，  3，  4，  5，  1，  2，  3，  4。其中 5 只出现了一次，其他都出现了两次，把他们全部异或一下，结果如下：
由于异或支持交换律和结合律，所以:

```
1^2^3^4^5^1^2^3^4 = （1^1)^(2^2)^(3^3)^(4^4)^5= 0^0^0^0^5 = 5。
```

也就是说，那些出现了两次的数异或之后会变成0，那个出现一次的数，和 0 异或之后就等于它本身。就问这个解法牛不牛逼？所以代码如下

```
int find(int[] arr){
    int tmp = arr[0];
    for(int i = 1;i < arr.length; i++){
        tmp = tmp ^ arr[i];
    }
    return tmp;
}
```

时间复杂度为 O(n)，空间复杂度为 O(1)。

### 2的n次方

如果让你求解 2 的 n 次方，并且不能使用系统自带的 pow 函数，你会怎么做呢？这还不简单，连续让 n 个 2 相乘就行了，代码如下：

```
int pow(int n){
    int tmp = 1;
    for(int i = 1; i <= n; i++) {
        tmp = tmp * 2;
    }
    return tmp;
}
```


不过你要是这样做的话，我只能呵呵，时间复杂度为 O(n) 了，怕是小学生都会！如果让你用位运算来做，你会怎么做呢？
我举个例子吧，例如 n = 13，则 n 的二进制表示为 1101, 那么 2 的 13 次方可以拆解为:
2^1101 = 2^0001 * 2^0100 * 2^1000。
我们可以通过 & 1和 >>1 来逐位读取 1101，为1时将该位代表的乘数累乘到最终结果。直接看代码吧，反而容易理解：

```
int pow(int n){
    int sum = 1;
    int tmp = 2;
    while(n != 0){
        if(n & 1 == 1){
            sum *= tmp;
        }
        tmp *= tmp;
        n = n >> 1;
    }

    return sum;
}
```


时间复杂度近为 O(logn)，而且看起来很牛逼。
这里说一下，位运算很多情况下都是很二进制扯上关系的，所以我们要判断是否是否位运算，很多情况下都会把他们拆分成二进制，然后观察特性，或者就是利用与，或，异或的特性来观察，总之，我觉得多看一些例子，加上自己多动手，就比较容易上手了。所以呢，继续往下看，注意，先别看答案，先看看自己会不会做。

### 找出不大于N的最大的2的幂指数

传统的做法就是让 1 不断着乘以 2，代码如下：

```
int findN(int N){
    int sum = 1;
   while(true){
        if(sum * 2 > N){
            return sum;
        }
        sum = sum * 2;
   }
}
```


这样做的话，时间复杂度是 O(logn)，那如果改成位运算，该怎么做呢？我刚才说了，如果要弄成位运算的方式，很多时候我们把某个数拆成二进制，然后看看有哪些发现。这里我举个例子吧。
例如 N = 19，那么转换成二进制就是 00010011（这里为了方便，我采用8位的二进制来表示）。那么我们要找的数就是，把二进制中最左边的 1 保留，后面的 1 全部变为 0。即我们的目标数是 00010000。那么如何获得这个数呢？相应解法如下：

1. 找到最左边的 1，然后把它右边的所有 0 变成 1

2. 把得到的数值加 1，可以得到 00100000即 00011111 + 1 = 00100000。

3. 把 得到的 00100000 向右移动一位，即可得到 00010000，即 00100000 >> 1 = 00010000。

那么问题来了，第一步中把最左边 1 中后面的 0 转化为 1 该怎么弄呢？我先给出代码再解释吧。下面这段代码就可以把最左边 1 中后面的 0 全部转化为 1，

```
n |= n >> 1;
n |= n >> 2;
n |= n >> 4;
```

就是通过把 n 右移并且做或运算即可得到。我解释下吧，我们假设最左边的 1 处于二进制位中的第 k 位(从左往右数),那么把 n 右移一位之后，那么得到的结果中第 k+1 位也必定为 1,然后把 n 与右移后的结果做或运算，那么得到的结果中第 k 和 第 k + 1 位必定是 1;同样的道理，再次把 n 右移两位，那么得到的结果中第 k+2和第 k+3 位必定是 1,然后再次做或运算，那么就能得到第 k, k+1, k+2, k+3 都是 1，如此往复下去….
最终的代码如下

```
int findN(int n){
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8 // 整型一般是 32 位，上面我是假设 8 位。
    return (n + 1) >> 1;
}
```


这种做法的时间复杂度近似 O(1)

### 二进制数中1的个数

```
public int count(int n){
    int count = 0;
    while(n>0){
        if(n&1==1){//判断最后一位是不是1
            count++;
        }
        n>>=1;//移位 丢弃最后一位 （1001 变成 100）
    }
    return count;
}
```

