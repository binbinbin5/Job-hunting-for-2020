[TOC]


# 1. 并发 #

## 线程状态
- 新建:创建后为运行
- 运行:包含Running和Ready
- 无限期等待:需要显示被唤醒,不会被分配CPU时间
- 等待:一定时间后被系统唤醒
    - sleep();
    - Object.wait();
    - Thread.join();
    - LockSupport的方法
- 阻塞:等待获取排它锁
- 结束:线程终止,终止不能被复生会报错
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/0cfa9e52906b05f57b1ae02cd3f7511c.jpg)
## 进程和线程

1. 串行
    - 多个任务，执行时一个执行完再执行另一个。
    - 比喻：吃完饭再看视频。

2. 并发
    - 多个线程在单个核心运行，同一时间一个线程运行，系统不停切换线程，看起来像同时运行，实际上是线程不停切换。
    - 比喻： 一会跑去厨房吃饭，一会跑去客厅看视频。

3. 并行
    - 每个线程分配给独立的核心，线程同时运行。
    - 比喻：一边吃饭一边看视频。


进程是资源分配的最小单位,线程是CPU调度的最小单位.

线程属于进程,进程是抢占处理机的调度单位.

1. 线程不能看做独立应用,进程可以看成独立应用.
2. 进程有独立的地址空间不影响,线程只是进程的不同执行路径
3. 线程没有独立的地址空间,多进程的程序比多线程健壮
4. 进程切换比线程切换开销大
5. 一个进程至少包含一个线程
6. 每个JVM实例对应一个进程,多个线程共享其堆.
```
一般一个CPU核心对应一个进程，一个进程可以包含多个线程。多核CPU可以进行并行加并发。
```


- 进程是操作系统进行资源（包括cpu、内存、磁盘IO等）分配的最小单位。
- 线程是cpu调度和分配的基本单位。
- 我们打开的聊天工具，浏览器都是一个进程。
- 进程可能有多个子任务，比如聊天工具要接受消息，发送消息，这些子任务就是线程。
- 资源分配给进程，线程共享进程资源。

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190625141007.png)
## 并发优点
- 充分利用多核CPU的计算能力；
- 方便进行业务拆分，提升应用性能
- 提高系统的吞吐率
- 提高响应性
- 充分利用多核处理器资源
- 最小化对系统资源的使用
- 简化程序的结构

## 计算机可以支持最多多少线程？
这取决于你使用的CPU，操作系统，其他进程正在做的事情，你使用的Java的版本，还有其他的因素。

绝对理论上的最大线程数是进程的用户地址空间除以线程栈的大小（现实中，如果内存全部给线程栈使用，就不会有能运行的程序了）。因此，以32位Windows系统为例，每一个进程的用户地址空间是2G，假如每个线程栈的大小是128K，最多会有16384(=210241024 / 128)个线程。实际在XP系统上，我发现大约能启动13000个线程。

其他来说：你可以在Thread的构造函数中设置线程栈的大小。这里有很多的参数（可以设置）。对于特定的虚拟机，都会有自己的运行时参数。（最大线程数）一定程度上由操作系统决定的：底层的操作系统要给线程提供哪些支持？施加哪些限制？虚拟机使用的是原生的操作系统的线程还是red thread或者green thread？

>多核下线程数量选择

- 计算密集型：程序主要为复杂的逻辑判断和复杂的运算。cpu的利用率高，不用开太多的线程，开太多线程反而会因为线程切换时切换上下文而浪费资源。

- IO密集型：程序主要为IO操作，比如磁盘IO(读取文件)和网络IO(网络请求)。因为IO操作会阻塞线程，cpu利用率不高，可以开多点线程，阻塞时可以切换到其他就绪线程，提高cpu利用率。



# 2. 并发编程有哪些缺点 #

- 线程安全
- 线程活性
    - 死锁（Deadlock）
    - 锁死（Lockout）
    - 活锁（Livelock）
    - 饥饿（Starvation）
- 上下文切换
    - 这是属于额外的资源消耗
- 可靠性

## 2.1 上下文切换

==时间片==：即使单核CPU也能运行多线程，多个线程会争取CPU的时间，也叫时间片，CPU通过时间片分配算法来再线程之间来回切换，对于用户来说这些切换的十几毫秒根本没有反应，好像线程一起并发执行一样。

>线程切换:
- cpu给线程分配时间片(也就是分配给线程的时间)，执行完时间片后会切换都另一个线程。
- 切换之前会保存线程的状态，下次时间片再给这个线程时才能知道当前状态。
- 从保存线程A的状态再到切换到线程B时，重新加载线程B的状态的这个过程就叫上下文切换。
- 而上下切换时会消耗大量的cpu时间。

>并发速度一定快吗？

并行不一定比串行快，因为CPU再由一个线程切换另一个线程的时候，需要保留该线程的状态。切换回来的时候，==保存-恢复会消耗额外时间，整个时间就叫上下文切换==。
由于上下文切换也是个相对比较耗时的操作，所以在"java并发编程的艺术"一书中有过一个实验，并发累加未必会比串行累加速度要快。 可以使用**Lmbench3测量上下文切换的时长** （ **vmstat测量上下文切换次数**）
>线程开销
- 上下文切换消耗
- 线程创建和消亡的开销
- 线程需要保存维持线程本地栈，会消耗内存
>如何避免频繁的上下文切换：

- ==无锁并发编程==：可以参照concurrentHashMap锁分段的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间。
- ==CAS算法==，利用Atomic下使用CAS算法来更新数据，使用了乐观锁，可以有效的减少一部分不必要的锁竞争带来的上下文切换
- ==使用最少线程==：避免创建不需要的线程，比如任务很少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态
- ==协程==：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

## 2.2 阻塞唤醒的代价

线程是映射到操作系统原生线程上的，如果要阻塞或唤醒一个线程就需要操作系统的介入，需要在用户态和核心态之间转换，这种转换会消耗大量的系统资源，因为用户态和内核态都有自己做专用的内存空间，专用寄存器，用户态切换到内核涂改需要传递许多变量参数给内核，内核也要保护切换时候的寄存器值和变量等，以便切换回用户态继续工作。
1. 如果线程切换是一个高频操作，那么会消耗许多CPU资源（处理）
2. 如果对于需要同步的简单代码块，获取锁挂起操作消耗的时间比用户代码执行时间长；


## 2.3 线程安全-死锁 ##


多线程编程中最难以把握的就是临界区线程安全问题，稍微不注意就会出现**死锁**的情况，一旦产生死锁就会造成系统功能不可用。


```
public class DeadLockDemo {
	    private static String resource_a = "A";
	    private static String resource_b = "B";
	
	    public static void main(String[] args) {
	        deadLock();
	    }
	
	    public static void deadLock() {
	        Thread threadA = new Thread(new Runnable() {
	            @Override
	            public void run() {
	                synchronized (resource_a) {
	                    System.out.println("get resource a");
	                    try {
	                        Thread.sleep(3000);
	                        synchronized (resource_b) {
	                            System.out.println("get resource b");
	                        }
	                    } catch (InterruptedException e) {
	                        e.printStackTrace();
	                    }
	                }
	            }
	        });
	        Thread threadB = new Thread(new Runnable() {
	            @Override
	            public void run() {
	                synchronized (resource_b) {
	                    System.out.println("get resource b");
	                    synchronized (resource_a) {
	                        System.out.println("get resource a");
	                    }
	                }
	            }
	        });
	        threadA.start();
	        threadB.start();
	
	    }
	}
```


在上面的这个demo中，开启了两个线程threadA, threadB,其中threadA占用了resource_a, 并等待被threadB释放的resource _b。threadB占用了resource _b正在等待被threadA释放的resource _a。因此threadA,threadB出现线程安全的问题，形成死锁。同样可以通过jps,jstack证明这种推论：


```
"Thread-1":
	  waiting to lock monitor 0x000000000b695360 (object 0x00000007d5ff53a8, a java.lang.String),
	  which is held by "Thread-0"
	"Thread-0":
	  waiting to lock monitor 0x000000000b697c10 (object 0x00000007d5ff53d8, a java.lang.String),
	  which is held by "Thread-1"
	
	Java stack information for the threads listed above:
	===================================================
	"Thread-1":
	        at learn.DeadLockDemo$2.run(DeadLockDemo.java:34)
	        - waiting to lock <0x00000007d5ff53a8(a java.lang.String)
	        - locked <0x00000007d5ff53d8(a java.lang.String)
	        at java.lang.Thread.run(Thread.java:722)
	"Thread-0":
	        at learn.DeadLockDemo$1.run(DeadLockDemo.java:20)
	        - waiting to lock <0x00000007d5ff53d8(a java.lang.String)
	        - locked <0x00000007d5ff53a8(a java.lang.String)
	        at java.lang.Thread.run(Thread.java:722)
	
	Found 1 deadlock.
```


 
如上所述，完全可以看出当前死锁的情况。

==避免死锁==
那么，通常可以用如下方式避免死锁的情况：

1. 避免一个线程同时获得多个锁；
2. 避免一个线程在锁内部占有多个资源，尽量保证每个锁只占用一个资源；
3. 尝试使用定时锁(避免无限制等待)，使用lock.tryLock(timeOut)，当超时等待时当前线程不会阻塞；
4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

所以，如何正确的使用多线程编程技术有很大的学问，比如如何保证线程安全，如何正确理解由于JMM内存模型在原子性，有序性，可见性带来的问题，比如数据脏读，DCL等这些问题。



# 3. 概念 #



## 进行、线程和任务

- 　进程（process）常常被定义为程序的执行。可以把一个进程看成是一个独立的程序,在内存中有其完备的数据空间和代码空间。一个进程所拥有的数据和变量只属于它自己。
- 　线程（tread）则是某一进程中一路单独运行的程序。也就是说,线程存在于进程之中。一个进程由一个或多个线程构成,各线程共享相同的代码和全局数据,但各有其自己的堆栈。由于堆栈是每个线程一个,所以局部变量对每一线程来说是私有的。由于所有线程共享同样的代码和全局数据,它们比进程更紧密,比单独的进
-  任务（task）是最抽象的,是一个一般性的术语,指由软件完成的一个活动（线程完成的计算叫任务）。一个任务既可以是一个进程,也可以是一个线程。简而言之,它指的是一系列共同达到某一目的的操作。例如,读取数据并将数据放入内存中。这个任务可以作为一个进程来实现,也可以作为一个线程（或作为一个中断任务）来实现。


```
任务 - 线程 - 进程
```


##  同步VS异步 ##

1. ==同步==：进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。
1. ==异步==：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。


同步和异步通常用来形容一次方法调用。同步方法调用一开始，调用者必须等待被调用的方法结束后，调用者后面的代码才能执行。而异步调用，指的是，调用者不用管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。

比如，在超时购物，如果一件物品没了，你得等仓库人员跟你调货，直到仓库人员跟你把货物送过来，你才能继续去收银台付款，这就类似同步调用。而异步调用了，就像网购，你在网上付款下单后，什么事就不用管了，该干嘛就干嘛去了，当货物到达后你收到通知去取就好。

- 异步和多线程并不是一个同等关系：异步是最终目的,多线程只是我们实现异步的一种手段。
- 异步和同步的区别:  在io等待的时候，同步不会切走，浪费了时间。


##  并发与并行 ##
并发和并行是十分容易混淆的概念。并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进行”。实际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。
- 1.并发：多个线程操作相同的资源，保证线程安全，合理利用资源。（单核处理器上多线程就是交替轮转，多核处理器上就死每个线程都被分配到一个处理器核上，同时运行）
- 2.高并发：服务能够同时处理很多请求，提高程序性能。（分布式系统架构设置中考虑因素：比如双十一、12306抢票）
- 3.并行性（parallel）：指在同一时刻，有多条指令在多个处理器上同时执行；

##  阻塞和非阻塞 ##
阻塞和非阻塞通常用来形容多线程间的相互影响，比如一个线程占有了临界区资源，那么其他线程需要这个资源就必须进行等待该资源的释放，会导致等待的线程挂起，这种情况就是阻塞，而非阻塞就恰好相反，它强调没有一个线程可以阻塞其他线程，所有的线程都会尝试地往前运行。

## 临界区 ##
临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。

- ==互斥==：进程间相互排斥的使用临界资源的现象，就叫互斥。
- 线程饥饿：某些线程永远得不到运行机会占用资源，可能由于优先级使用不当导致。



## CPU多级缓存
> 缓存cache是为了缓解CPU和内存之间速度不匹配而存在，其还有两个优势：
- 时间局部性：某个数据多次被访问
- 空间局部性：某个数据被访问，那么相邻空间的数据很快被访问


##  缓存一致性：
>用于保证多个CPU cache之间缓存共享数据的一致。下面有4种缓冲行：
1. M 被修改 （只被缓存在该CPU中，而且被修改过的，与主存不一样）
2. E 独享（写回主存，没有修改过，当其他CPU进行读取时变成共享状态，修改则变成M状态）
3. S 共享（可能被多个CPU进行缓存，与主存数据一致，当一个CPU修改，则其他变成I作废）
4. I 无效 （表示无效，修改了该缓冲行）

##  乱序执行（重排序）
在单线程的情况下有乱序执行优化不会打破程序运行结果（有数据依赖的不会被乱系），但在多线程中会打破运行的结果.

##  高并发和多线程
1. ==多线程==：多个线程并发执行的技术。
1. ==高并发==：一种系统运行过程中遇到的一种“短时间内遇到大量操作请求”的情况，主要发生在web系统集中大量访问或者socket端口集中性收到大量请求（例如：12306的抢票情况；天猫双十一活动）。该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。如果要想系统能够适应高并发状态，则需要从各个方面进行系统优化，包括，硬件、网络、系统架构、开发语言的选取、数据结构的运用、算法优化、数据库优化……而多线程只是其中解决方法之一。

-  高并发 ≠ 多线程：多线程是完成任务的一种方法，高并发是系统运行的一种状态，通过多线程有助于系统承受高并发状态的实现。

# 资源争用和调度
- 公平调度策略：
按照申请的先后顺序进行授予资源的独占权
- 非公平调度策略：
没有按照先后顺序授予资源的独占权
- 非公平调度的解释：
    - 在该策略中，资源的持有线程释放该资源的时候，等待队列中一个线程会被唤醒，而该线程从被唤醒到其继续执行可能需要一段时间。在该时间内，新来的线程（活跃线程）可以先被授予该资源的独占权。
    - 如果新来的线程占用该资源的时间不长，那么它完全有可能在被唤醒的线程继续执行前释放相应的资源，从而不影响该被唤醒的线程申请资源。


非公平调度策略和公平调度策略的优缺点分析：
- 非公平调度策略：
    - 优点：前者吞吐率较高，即单位时间内可以为更多的申请者调配资源；
    - 缺点：资源申请者申请资源所需的时间偏差可能较大，并可能出现线程饥饿的现象
- 公平调度策略：
    - 优点：适合在资源的持有线程占用资源的时间相对长或者资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用；线程申请资源所需的时间偏差较小；不会出现线程饥饿的现象
    - 缺点：吞吐率较小

# 资源限制

## 1.软件资源

池化复用：池化技术能够减少资源对象的创建次数，提高程序的性能，特别是在高并发下这种提高更加明显。使用池化技术缓存的资源对象有如下共同特点：1，对象创建时间长；2，对象创建需要大量资源；3，对象创建后可被重复使用


1. 数据库连接数
2. socket连接数


## 2.硬件资源

1. 带宽有限（下载上传速度限制）
2. CPU和内存有限(集群)
3. 硬盘读写速度有限：将数据放入内存（redis，elasticsearch）

提高性能的方式：
- 提高硬件水平，处理速度或核心数。
- 另一种方式：根据实际场景，合理设置线程数，软件上提高cpu利用率。