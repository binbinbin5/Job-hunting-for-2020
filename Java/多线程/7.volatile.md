[toc]
## 1、介绍

有时候线程之间会有如此情况：
### a.失效数据：
在没有同步的情况下，线程去读取变量时，可能会得到一个已经失效的值。失效值可能不会同时出现：一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。
### b.最低安全性：
- 线程没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性（out-of-thin-airsafety）。
- 最低安全性适用于绝大多数变量，当时存在一个例外：非volatile类型的64位数值变量。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。
### c.加锁和可见性：
- 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步.

### 底层实现原理
1. 读写建立happen-before原则
2. 读写由JMM实现
    - JMM会把内存刷新到主存中，保证可见性
    - 重排序保证有序性
    - JMM中的内存屏障保证重排序和内存读写

## 2.解决：

### 1. 用来读取变量的相对新值

volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此读取volatile类型的变量时总会返回最新写入的值。

### 2. volatile被称为轻量级锁：volatile具有可见性、有序性。
#### 内存屏障
>具体描述
基本内存屏障可以分为：LoadLoad屏障、LoadStore屏障、StoreStore屏障和StoreLoad屏障。这些屏障可统一用XY来表示，XY屏障的作用是禁止屏障左侧的任何X操作与屏障右侧的任何Y操作之间进行重排序。

- **LoadLoad屏障：**

    对于这样的语句 Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。

- **StoreStore屏障：**

    对于这样的语句 Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。

- **LoadStore屏障：**

    对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被执行前，保证Load1要读取的数据被读取完毕。

- **StoreLoad屏障：**

    对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。



- **按照可见性保障来划分**：：**加载屏障（Load Barrier）和存储屏障（Store Barrier）**。

    - 加载屏障：StoreLoad屏障可充当加载屏障，作用是刷新处理器缓存，即清空无效化队列，使处理器在读取共享变量时，先从主内存或其他处理器的高速缓存中读取相应变量，更新到自己的缓存中
 
    - 存储屏障：StoreLoad屏障可充当存储屏障，作用是冲刷处理器缓存，即将写缓冲器内容写入高速缓存中，使处理器对共享变量的更新写入高速缓存或者主内存中

    这两个屏障一起保证了数据在多处理器之间是可见的。

- **按照有序性保障来划分**：**获取屏障（Acquire Barrier）和释放屏障（Release Barrier）**。

    - 获取屏障：相当于LoadLoad屏障与LoadStore屏障的组合。在读操作后插入，禁止该读操作与其后的任何读写操作发生重排序；
    - 释放屏障：相当于LoadStore屏障与StoreStore屏障的组合。在一个写操作之前插入，禁止该写操作与其前面的任何读写操作发生重排序。


>这两个屏障一起保证了临界区中的任何读写操作不可能被重排序到临界区之外。
volatile修饰的属性保证每次读取都能读到最新的值，但不会 & 无法更新 已经读了的值
原理

（1）修改volatile变量时会强制将修改后的值刷新的主内存中。写操作：如图

- Release Barrier 释放屏障（LoadStore屏障与StoreStore屏障）保证了volatile写操作与该操作之前的任何读、写操作都不会进行重排序。从而保证了volatile写操作之前，任何的读写操作都会先于volatile被提交。
- 而Store Barrier 存储屏障（StoreLoad屏障）除了使volatile写操作不会与之后的读操作重排序外，还会冲刷处理器缓存，使volatile变量的写更新对其他线程可见，该内存屏障与读操作的加载屏障一起保障了可见性。


（2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。读操作：如图

- 加载屏障（StoreLoad屏障）除了使volatile读操作不会与之前的写操作发生重排序外，还会刷新处理器缓存，使volatile变量读取的为最新值。
- 获取屏障（LoadLoad屏障与LoadStore屏障）禁止了volatile读操作与其之后的任何读写操作进行重排序。保障了volatile变量读操作之后的任何读写操作，volatile的写线程的更新已经对其可见。

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323631353738392d613331646261653538376538613934362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f77.png)

#### 保证有序性
- 具体描述
当对volatile修饰的属性进行读/写操作时，其前面的代码必须已执行完成 & 结果对后续的操作可见
- 原理
重排序时，以volatile修饰属性的读/写操作代码行为分界线，读/写操作前面的代码不许排序到后面，后面同理不许排序到前面。由此保证有序性

volatile一个强大的功能，==那就是他可以禁止指令重排优化==。通过禁止指令重排优化，就可以保证代码程序会严格按照代码的先后顺序执行。那么volatile又是如何禁止指令重排的呢？

先给出结论：volatile是通过内存屏障来来禁止指令重排的。

内存屏障（Memory Barrier）是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。


#### 保证可见性
==volatile对于可见性的实现，内存屏障也起着至关重要的作用。因为内存屏障相当于一个数据同步点，他要保证在这个同步点之后的读写操作必须在这个点之前的读写操作都执行完之后才可以执行。并且在遇到内存屏障的时候，缓存数据会和主存进行同步，或者把缓存数据写入主存、或者从主存把数据读取到缓存。==

>已经有了缓存一致性协议，为什么还需要volatile？

这个问题的答案可以从多个方面来回答：

1、并不是所有的硬件架构都提供了相同的一致性保证，Java作为一门跨平台语言，JVM需要提供一个统一的语义。



2、操作系统中的缓存和JVM中线程的本地内存并不是一回事，通常我们可以认为：MESI可以解决缓存层面的可见性问题。使用volatile关键字，可以解决JVM层面的可见性问题。



3、缓存可见性问题的延伸：由于传统的MESI协议的执行成本比较大。所以CPU通过Store Buffer和Invalidate Queue组件来解决，但是由于这两个组件的引入，也导致缓存和主存之间的通信并不是实时的。也就是说，缓存一致性模型只能保证缓存变更可以保证其他缓存也跟着改变，但是不能保证立刻、马上执行。

其实，在计算机内存模型中，也是使用内存屏障来解决缓存的可见性问题的（再次强调：缓存可见性和并发编程中的可见性可以互相类比，但是他们并不是一回事儿）。



写内存屏障（Store Memory Barrier）可以促使处理器将当前store buffer（存储缓存）的值写回主存。读内存屏障（Load Memory Barrier）可以促使处理器处理invalidate queue（失效队列）。进而避免由于Store Buffer和Invalidate Queue的非实时性带来的问题。



所以，内存屏障也是保证可见性的重要手段，操作系统通过内存屏障保证缓存间的可见性，JVM通过给volatile变量加入内存屏障保证线程之间的可见性。
#### 不保证原子性
那么，为什么volatile不能保证原子性呢？==因为他不是锁，他没做任何可以保证原子性的处理。当然就不能保证原子性了。==

- 具体描述
volatile修饰的属性若在修改前已读取了值，那么修改后，无法改变已经复制到工作内存的值
即无法阻止并发的情况
- 原理

```
// 变量a 被volatile修饰 
volatile static int a=0;
a++;
// 包含了2步操作：1 = 读取a、2= 执行a+1 & 将a+1结果赋值给a
// 设：线程A、B同时执行以下语句，线程A执行完第1步后被挂起、线程B执行了a++，那么主存中a的值为1
// 但线程A的工作内存中还是0，由于线程A之前已读取了a的值 = 0，执行a++后再次将a的值刷新到主存 = 1
// 即 a++执行了2次，但2次都是从0变为1，故a的值最终为1
```




### 3不会导致上下文切换

作用volatile关键字可以保证对long/double型变量的写操作具有原子性
在一些32位的处理器上，如果要求对64位数据的写操作具有原子性，会有比较大的开销。为了照顾这种处理器，Java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的写操作具有原子性。当JVM在这种处理器上运行时，可能会把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行。这两个32位的写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的写操作将不具有原子性.

### 4volatile会禁止指令重排(利用内存屏障)。

把变量声明为volatile类型后，编译器和运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。



　
## 3、适用场合：
    
### a.volatile变量的开销：
我们经常会说 volatile 比 synchronized 之类更加轻量，但轻量也仅仅是相对的，volatile 的读、写仍然要比普通的读写要开销更大，所以如果你是在性能高度敏感的场景，除非你确定需要它的语义，不然慎用。volatile写的开销比volatile读的开销会大很多（因为执行StoreLoad屏障开销会比较大）。
不会导致上下文切换，开销比锁小
读取变量的成本比临界区中读取变量要低，但是其读取成本可能比读取普通变量要高；因为每次读取都从高速缓存或者主内存中读取，无法被暂存在寄存器中，从而无法发挥访问的高效性

### b.仅当volatile变量能简化代码的实现以及对同步策略的验证时
   
 当且仅当满足以下所有条件时，才应该使用volatile变量：
- 　1对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
- 　2该变量不会与其他状态变量一起纳入不变性条件中。
- 　3在访问变量时不需要加锁。

 下面列举几个Java中使用volatile的几个场景。
- 1.状态标记量
- 2.double check 双重检查
- 3.保障可见性
- 4.代替锁
利用该变量对写操作的原子性
volatile适合多个线程共享一个状态变量，锁适合多个线程共享一组状态变量
我们可以将多个线程共享的一组状态变量合并成一个对象，用于一个volatile变量来引用该对象，从而替代锁
- 5.实现简易版读写锁
### c.单例模式

```
public class Singleton{  
   private static volatile Singleton instance = null;
   //是否是final的不重要，因为最多只可能实例化一次。
   //volatile保障禁止重排序(禁止先指向分配内存而不是先初始化对象)
   private Singleton(){}  
   public static Singleton getInstance(){  
   //第一次检测
       if(instance == null){  
           //双重检查加锁，只有在第一次实例化时，才启用同步机制，提高了性能。  
           synchronized(Singleton.Class){  //第一次检测，如果有就不进来 假设AB两个线程争夺，A获取B等待
               if(instance == null){  //放置多线程A之前已经创建过对象了B就不创建了
                   instance = new Singleton();  
               }  
           }  
       }  
       return instance;  
   }  
}  
```


## 4、原理

>volatile用以声明变量的值可能随时会别的线程修改，使用volatile修饰的变量会强制将修改的值立即写入主存，主存中值的更新会使缓存中的值失效。(非volatile变量不具备这样的特性，非volatile变量的值会被缓存，线程A更新了这个值，线程B读取这个变量的值时可能读到的并不是是线程A更新后的值)。





```
class VolatileExample {
    int a = 0;
    volatile boolean flag = false;

    public void writer() {
        a = 1;                   //1
        flag = true;               //2
    }

    public void reader() {
        if (flag) {                //3
            int i =  a;           //4
            ……
        }
    }
}
```


假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens before规则，这个过程建立的happens before 关系可以分为两类：
- 根据程序次序规则，1 happens before 2; 3 happens before 4。
- 根据volatile规则，2 happens before 3。
- 根据happens before 的传递性规则，1 happens before 4。




## 4、volatile关键字和synchronized关键字的区别
- volatile本质是在告诉JVM当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住直到该线程完成变量操作为止.
- volatile只能作用于变量，使用范围较小。synchronized可以用在变量、方法、类、同步代码块等，使用范围比较广。 
- volatile只能保证可见性和有序性，不能保证原子性。而可见性、有序性、原子性synchronized都可以包证。 
- volatile不会造成线程阻塞。synchronized可能会造成线程阻塞。
- volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化.