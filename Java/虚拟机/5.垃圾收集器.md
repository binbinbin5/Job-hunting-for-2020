[toc]

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/uituty.jpg)

## 1. Serial收集器

### 1.1 定义

最基本、发展历史最长的垃圾收集器

### 1.2 优点

- 并发收集

1. 在进行垃圾收集时，必须暂停其他所有工作线程（Stop The World），直到收集结束。Stop The World 暂停工作线程 是在用户不可见的情况下进行 

2. 并发与并行的区别 
    1. 并发：在 某一时段内，交替执行多个任务（即先处理A再处理B，循环该过程） 
    2. 并行：在 某一时刻内，同时执行多个任务（即同时处理A、B） 

- 单线程

    - 只使用 一条线程 完成垃圾收集（GC线程） 

- 效率高

    - 对于限定单CPU环境来说，Serial收集器没有线程交互开销（专一做垃圾收集），拥有更高的单线程收集效率。

    - 垃圾收集高效:即其他工作线程停顿时间短（可控制在100ms内） 只要垃圾收集发生的频率不高，完全可以接受 



### 1.3 使用的垃圾收集算法

复制 算法（新生代）

### 1.4 应用场景

客户端模式下，虚拟机的 新生代区域

### 1.5 工作流程

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/qwqwq.jpg)

## 2. Serial Old收集器

### 2.1 定义

Serial收集器 应用在老年代区域 的版本

### 2.2 优点

并发、单线程、效率高

同Serial收集器，此处不作过多描述

### 2.3 使用的垃圾收集算法

标记-整理 算法（老年代）

### 2.4 应用场景

- 在客户端模式下，虚拟机的老年代区域
- 在服务器模式下：

- 1. 与 Parallel Scavenge 收集器搭配使用
  2. 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用

### 2.5 工作流程



![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/wqqqq.jpg)

## 3. ParNew 收集器

### 3.1 定义

Serial收集器 的 多线程 版本。

### 3.2 优点

- 并发收集

    - 在进行垃圾收集时，必须暂停其他所有工作线程（Stop The World），直到收集结束。 暂停工作线程是在用户不可见的情况下进行 

- 多线程收集

    - 使用 多条垃圾收集线程（GC线程） 完成垃圾收集

    - 由于存在线程交互的开销，所以在单CPU环境下，性能差于 Serial收集器

- 与CMS收集器配合工作

    - 目前，只有ParNew 收集器能与 CMS收集器 配合工作
        1. 由于CMS收集器使用广泛，所以该特点非常重要。
        2. 关于CMS收集器 下面会详细说明

### 3.3 使用的垃圾收集算法

复制 算法（新生代）

### 3.4 应用场景

- 服务器模式下，虚拟机的 新生代区域

- 多线程收集 

### 3.5 工作流程

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/dqewqw.jpg)



## 4. Parallel Scavenge收集器

### 4.1 定义

ParNew 收集器的升级版

### 4.2 特点

- 具备ParNew 收集器并发、多线程收集的特点
- 以达到 可控制吞吐量 为目标

其他收集器的目标是： 尽可能缩短 垃圾收集时间，

而Parallel Scavenge收集器的目标则是：达到 可控制吞吐量

1. 吞吐量：CPU用于运行用户代码的时间 与 CPU总消耗时间（运行用户代码时间+垃圾收集时间）的比值
2. 如：虚拟机总共运行100分钟，其中垃圾收集时间=1分钟、运行用户代码时间 = 99分钟，那吞吐量 = 99 / 100 = 99%

- 自适应

该垃圾收集器能根据当前系统运行情况，动态调整自身参数，从而达到最大吞吐量的目标。

1. 该特性称为：GC 自适应的调节策略
2. 这是Parallel Scavenge收集器与 ParNew 收集器 最大的区别

### 4.3 使用的垃圾收集算法

复制 算法（新生代）

### 4.4 应用场景

服务器模式下，虚拟机的 新生代区域

### 4.5 工作流程



![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/trer.jpg)

## 5. Parallel Old收集器

### 5.1 定义

Parallel Scavenge收集器 应用在老年代区域 的版本

### 5.2 特点

以达到 可控制吞吐量 为目标、自适应调节、多线程收集

同Parallel Scavenge收集器

### 5.3 使用的垃圾收集算法

标记-整理 算法（老年代）

### 5.4 应用场景

服务器模式下，虚拟机的 老年代区域

### 5.5 工作流程

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/qweqweqw.jpg)

## 6. CMS收集器

### 6.1 定义

即Concurrent Mark Sweep，基于 标记-清除算法的收集器

### 6.2 特点

6.2.1 优点

- 并行

用户线程 & 垃圾收集线程同时进行。 即在进行垃圾收集时，用户还能工作（重点）。 

- 单线程收集

只使用 一条线程 完成垃圾收集（GC线程） 

- 垃圾收集停顿时间短

该收集器的目标是： 获取最短回收停顿时间 ， 即希望 系统停顿的时间 最短，提高响应速度 

6.2.2 缺点

- 总吞吐量会降低

因为该收集器对CPU资源非常敏感，在并发阶段，虽不会导致用户线程停顿，但会因为占用部分线程（CPU资源）而导致应用程序变慢，总吞吐量会降低

- 无法处理浮动垃圾

由于 并发清理时 用户线程还在运行，所以会有新的垃圾不断产生（即浮动垃圾），只能等到留待下一次GC时再清理掉。

1. 因为这一部分垃圾出现在标记过程之后，所以CMS无法在当次GC中处理掉它们
2. 因此，CMS无法等到老年代被填满再进行Full GC，CMS需要预留一部分空间。即所谓的：可能出现Concurrent Mode Failure失败而导致另一次Full GC产生。

- 垃圾收集后会产生大量内存空间碎片



### 6.3 使用的垃圾收集算法

标记-清除 算法（老年代）

### 6.4 应用场景

重视应用的响应速度、希望系统停顿时间最短的场景

如互联网移动端应用 

### 6.5 工作流程
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/erqw1.jpg)
- CMS 收集器 是基于 标记-清除算法实现的收集器，工作流程较为复杂：（分为四个步骤）

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/55552.jpg)

 **初始标记、从新标记这两个步骤仍然需要“stop the world”，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，熟读很快，并发标记阶段就是进行GC Roots Tracing，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生表动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长点，但远比并发标记的时间短。**



1. 对象在标记过程中，根据标记情况，分成三类：
    - 白色对象，表示自身未被标记；
    - 灰色对象，表示自身被标记，但内部引用未被处理；
    - 黑色对象，表示自身被标记，内部引用都被处理；

    InitialMarking（初始化标记，整个过程STW）
    该阶段单线程执行，主要分分为两步：
    - 标记GC Roots可达的老年代对象；
    - 遍历新生代对象，标记可达的老年代对象；
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/file/20190804151936.png)

2. Marking（并发标记）

    该阶段GC线程和应用线程并发执行，遍历InitialMarking阶段标记出来的存活对象，然后继续递归标记这些对象可达的对象。

    因为该阶段并发执行的，在运行期间可能发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况。
    
    为了提高重新标记的效率，该阶段会把上述对象所在的Card标识为Dirty，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代。

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/file/20190804152010.png)

3. Precleaning（预清理）
    
    通过参数CMSPrecleaningEnabled选择关闭该阶段，默认启用，主要做两件事情：

    处理新生代已经发现的引用，比如在并发阶段，在Eden区中分配了一个A对象，A对象引用了一个老年代对象B（这个B之前没有被标记），在这个阶段就会标记对象B为活跃对象。
    
    在并发标记阶段，如果老年代中有对象内部引用发生变化，会把所在的Card标记为Dirty（其实这里并非使用CardTable，而是一个类似的数据结构，叫ModUnionTalble），通过扫描这些Table，重新标记那些在并发标记阶段引用被更新的对象（晋升到老年代的对象、原本就在老年代的对象）


4. bortablePreclean（可中断的预清理）

该阶段发生的前提是，新生代Eden区的内存使用量大于参数CMSScheduleRemarkEdenSizeThreshold 默认是2M，如果新生代的对象太少，就没有必要执行该阶段，直接执行重新标记阶段。

为什么需要这个阶段，存在的价值是什么？
因为CMS GC的终极目标是降低垃圾回收时的暂停时间，所以在该阶段要尽最大的努力去处理那些在并发阶段被应用线程更新的老年代对象，这样在暂停的重新标记阶段就可以少处理一些，暂停时间也会相应的降低。

在该阶段，主要循环的做两件事：

- 处理 From 和 To 区的对象，标记可达的老年代对象
- 和上一个阶段一样，扫描处理Dirty Card中的对象

- 当然了，这个逻辑不会一直循环下去，打断这个循环的条件有三个：
    1. 可以设置最多循环的次数 CMSMaxAbortablePrecleanLoops，默认是0，意思没有循环次数的限制。
    1. 如果执行这个逻辑的时间达到了阈值CMSMaxAbortablePrecleanTime，默认是5s，会退出循环。
    1. 如果新生代Eden区的内存使用率达到了阈值CMSScheduleRemarkEdenPenetration，默认50%，会退出循环。（这个条件能够成立的前提是，在进行Precleaning时，Eden区的使用率小于十分之一）

5. FinalMarking（并发重新标记，STW过程）
该阶段并发执行，在之前的并行阶段（GC线程和应用线程同时执行，好比你妈在打扫房间，你还在扔纸屑），可能产生新的引用关系如下：

    1. 老年代的新对象被GC Roots引用
    1. 老年代的未标记对象被新生代对象引用
    1. 老年代已标记的对象增加新引用指向老年代其它对象
    1. 新生代对象指向老年代引用被删除
    1. 也许还有其它情况..

上述对象中可能有一些已经在Precleaning阶段和AbortablePreclean阶段被处理过，但总存在没来得及处理的，所以还有进行如下的处理：

遍历新生代对象，重新标记
根据GC Roots，重新标记
遍历老年代的Dirty Card，重新标记，这里的Dirty Card大部分已经在clean阶段处理过

在第一步骤中，需要遍历新生代的全部对象，如果新生代的使用率很高，需要遍历处理的对象也很多，这对于这个阶段的总耗时来说，是个灾难（因为可能大量的对象是暂时存活的，而且这些对象也可能引用大量的老年代对象，造成很多应该回收的老年代对象而没有被回收，遍历递归的次数也增加不少），如果在AbortablePreclean阶段中能够恰好的发生一次YGC，这样就可以避免扫描无效的对象。



## 7. G1 收集器
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/563463.jpg)
### 7.1 定义

最新、技术最前沿的垃圾收集器

### 7.2 特点

- 并行

用户线程 & 垃圾收集线程同时进行。

即在进行垃圾收集时，用户还能工作

- 多线程

即使用 多条垃圾收集线程（GC线程） 进行垃圾收集

并发 & 并行 充分利用多CPU、多核环境下的硬件优势 来缩短 垃圾收集的停顿时间

- 垃圾回收效率高

G1 收集器是 针对性 对 Java堆内存区域进行垃圾收集，而非每次都对整个 Java 堆内存区域进行垃圾收集。

1. 即 G1收集器除了将 Java 堆内存区域分为新生代 & 老年代之外，还会细分为许多个大小相等的独立区域（ Region），然后G1收集器会跟踪每个 Region里的垃圾价值大小，并在后台维护一个列表；每次回收时，会根据允许的垃圾收集时间 优先回收价值最大的Region，从而避免了对整个Java堆内存区域进行垃圾收集，从而提高效率。
2. 因为上述机制，G1收集器还能建立可预测的停顿时间模型：即让 使用者 明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得从超出N毫秒。即具备实时性

- 分代收集

同时应用在 内存区域的新生代 & 老年代

- 不会产生内存空间碎片

  1. 从整体上看，G1 收集器是基于 标记-整理算法实现的收集器
  2. 从局部上看，是基于 复制算法 实现

上述两种算法意味着 G1 收集器不会产生内存空间碎片。

### 7.3 使用的垃圾收集算法

- 对于新生代：复制算法
- 对于老年代：标记 - 整理算法

### 7.4 应用场景

服务器端虚拟机的内存区域（包括 新生代 & 老年代）

### 7.5 工作流程

- G1 收集器的工作流程分为4个步骤：


![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/weqweqw.jpg)



- 新生代：eden space + 2个survivor
- 老年代：old space
- 持久代：1.8之前的perm space
- 元空间：1.8之后的metaspace

这些space必须是地址连续的空间。

在G1算法中，采用了另外一种完全不同的方式组织堆内存，堆内存被划分为多个大小相等的内存块（Region），每个Region是逻辑连续的一段内存，结构如下：

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/file/2184951-715388c6f6799bd9.png)

region 的大小是一致的，数值是在 1M 到 32M 字节之间的一个 2 的幂值数，JVM 会尽量划分 2048 个左右、同等大小的 region，这点可以从源码heapRegionBounds.hpp中看到。当然这个数字既可以手动调整，G1 也会根据堆大小自动进行调整。

在 G1 实现中，年代是个逻辑概念，具体体现在，一部分 region 是作为 Eden，一部分作为 Survivor，除了意料之中的 Old region，G1 会将超过 region 50% 大小的对象（在应用中，通常是 byte 或 char 数组）归类为 Humongous 对象，并放置在相应的 region 中。逻辑上，Humongous region 算是老年代的一部分，因为复制这样的大对象是很昂贵的操作，并不适合新生代 GC 的复制算法。

每个Region被标记了E、S、O和H，说明每个Region在运行时都充当了一种角色，其中H是以往算法中没有的，它代表Humongous，这表示这些Region存储的是巨型对象（humongous object，H-obj），当新建对象大小超过Region大小一半时，直接在新的一个或多个连续Region中分配，并标记为H。

G1中提供了三种模式垃圾回收模式，==young gc、mixed gc 和 full gc==，在不同的条件下被触发。

