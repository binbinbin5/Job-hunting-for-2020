[toc]

## Redis基本介绍

### 主流缓存应用架构

![](https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%BC%93%E5%AD%98%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84.png)

### 缓存中间件-Mencache和Redis区别

Memcache：代码层次类似Hash

- 支持简单的数据类型
- 不支持数据持久化存储
- 不支持主从
- 不支持分片（将大数据分片到多个物理节点的方案）

### 为什么Redis能这么快

- 完全基于内存才做，绝大部分请求是纯粹的内存操作，执行效率高
- 数据结构简单，对数据操作也简单
- 采用单线程，单线程也能处理高并发请求，想多核也可以启动多实例
- 使用多路I/O复用模型，非阻塞IO

### 多路I/O复用模型

FD：文件描述符

一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射

通过Select去监听多个FD，采用多路I/O复用函数

### 常用Reids的数据类型

- String：最基本的数据类型，二进制安全
- Hash：String元素组成的字典，适合用于存储对象
- List：列表，按照String元素插入顺序排序
- Set：String元素组成的无序集合，通过哈希表实现，不允许重复
- Sorted Set：通过分数来为集合中的成员从小到大排序
- HyperLogLog：用来做基数统计的算法
- Geo：支持存储地理位置信息

### 从海量数据查询某一前缀的key

KEYS pattern：查找所有符合给定模式pattern的key

- KEYS指令一次性返回所以匹配的key
- 键的数量过大会使服务卡顿

SCAN cursor [MATCH pattern] [COUNT count]

无阻塞的返回元素

- 基于游标的迭代器，需要基于上次的游标延续之前的迭代过程
- 以0作为游标开始一次新的迭代，直到命令返回游标0完成一次的遍历
- 不保存每次执行都返回某个给定数量的元素，支持模糊查询
- 一次返回数量不可靠，只能是大概率符合count参数

## 分布式锁

如何通过Redis实现分布式锁？

分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁的实现，如果不同系统或者同一个系统的不同主机之间，共享了某个资源时，往往需要互斥来防止彼此干扰，进而保证一致性。 

分布式锁需要解决的问题如下

- 互斥性：任意时刻下，只能有一个客户端能够获取锁
- 安全性：锁只能由持有该锁的客户端删除
- 死锁：某个客户端由于宕机未释放锁，而导致其它客户端无法获取锁死锁
- 容错：部分节点宕机，客户端仍能获取锁，释放锁

SETNX key value：如果key不存在，则创建并赋值

- 时间复杂度：O(1)
- 返回值：设置成功，返回1；设置失败，返回0

初期用来实现分布式锁，再执行某段代码逻辑时，先尝试使用SETNX对某个key设值成功，则证明此时没有别的线程在执行改段代码，或者说是在占用该独占资源。如果设置失败，则证明有别的程序或者线程占用该资源。

但是有一个问题，第一个线程SETNX成功后，便会长久存在，后续线程是不可再次获取锁。
为了解决SETNX长期有效的问题，可以用EXPIRE指令

EXPIRE key seconds

- 设置key的生存时间，当key过期时(生存时间为0)，会被自动删除
- 缺点：原子性得不到满足

![](https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%811.png)

也就是说参考伪代码的话，在未执行if语句时，客户端宕机，原子性得不到满足

在新版本中通过SET指令实现，相当于把SETNX和EXPIRE指令放在一起

SET key value [EX secondes] [PX milliseconds] [NX|XX]

- EX secondes:设置键的过期时间为second秒
- PX milliseconds：设置键的过期时间为milliseconds毫秒
- NX：只在键不存在时，才对键进行操作
- XX：只在键存在时，才对键进行操作
- SET操作成功时，返回OK，否则返回nil

大量的key同时过期，由于集中过期，容易出现卡顿，可以在key设置过期时间，每个key加上随机值

## 异步队列

使用Redis做异步队列

使用List作为队列，RPUSH生产消息，LPOP消费消息

- 缺点：没有等待队列里面有值就直接消费
- 弥补：可以通过在应用层引入Sleep机制去调用LPOP重试

如果不用Sleep重试，可以通过BLPOP指令

BLPOP key[key...] timeout:阻塞直到队列有消息或者超时

生产一次让多个消费者消费

pub/sub：主题订阅模式

- 发送者（pub）发送消息，订阅者（sub）接收消息
- 订阅者可以订阅任意数量的频道

缺点：消息的发布是无状态，无法保证可达

## 持久化

### RDB（快照）持久化

RDB（快照）持久化：保存某个时间点的全量数据快照

- SAVE：阻塞Redis的服务进程，直到RDB文件被创建完毕
- BGSAVE：fork出一个子进程创建RDB文件，不阻塞服务器进程

BGSAVE原理

![](https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/BGSAVE%E5%8E%9F%E7%90%86.png)

系统调用fork():创建进程，实现了Copy-on-Write

Copy-on-Write

如果有多个调用者同时要求相同资源（如内存或磁盘上的数据存储），他们回共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者锁见到的最初资源仍然保持不变

缺点

- 内存数据的全量同步，数据量大会由于I/O而严重影响性能
- 可能会因为Redis挂掉而丢失从当前至最近一次快照的数据

### AOF（Append-Only-File）持久化：保存写状态

- 记录下除了查询以外的所有变更数据库状态的指令
- 以append的心事追加保存到AOF文件中（增量）

日志重写解决AOF文件大小不断增大的问题，原理如下：

- 调用fork()，创建一个子进程
- 子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件
- 主进程持续将新的变动同时写到内存和原来的AOF里
- 主进程获取子进程重写AOF的完成信号，往新的AOF同步增量变动
- 使用新的AOF文件替换掉旧的AOF文件

### RDB和AOF文件共存下恢复流程

如果AOF文件存在就直接加载AOF，如果不存在就直接加载RDB文件

### RDB-AOF混合持久化方式

BGSAVE做镜像全量持久化，AOF做增量持久化

## 主从同步

Pipeline

大多数情况下，我们都会通过请求-相应机制去操作redis。只用这种模式的一般的步骤是，先获得jedis实例，然后通过jedis的get/put方法与redis交互。由于redis是单线程的，下一次请求必须等待上一次请求执行完成后才能继续执行。然而使用Pipeline模式，客户端可以一次性的发送多个命令，无需等待服务端返回。这样就大大的减少了网络往返时间，提高了系统性能。

### 主从同步原理

![](https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/20190916143756.png)

一个Master用于写的操作，若干个Slave用于读操作

全同步过程

- Slave发送sync命令到Master
- Master启动一个后台进程，将Redis中的数据快照保存到文件中
- Master将保存数据快照期间接收到的写命令缓存起来
- Master完成写文件操作后，将该文件发送给Slave
- 使用新的AOF文件去替换旧的AOF文件
- Master将这期间收集的增量写命令发送给Slave端

增量同步过程

- Master接收到用户的操作指令，判断是否需要传播到Slave
- 将操作记录追到到AOF文件
- 将操作传播到其他Slave：1、对齐主从库；2、往响应缓存写入指令
- 将缓存中的数据发送给Slave

Redis Sentinel（哨兵）

解决主从同步Master宕机后的主从切换问题：

- 监控：检查主从服务器是否运行正常
- 提醒：通过API向管理员活着其他应用程序发送故障通知
- 自动故障迁移：主从切换

## 集群

如何从海量数据里快速找到需要的数据？

- 分片：按照某种规则去划分数据，分散存储到多个节点上
- 常规的按照哈希划分无法实现节点的动态增减

### 一致性哈希算法：对2^32取模，将哈希值空间组织成虚拟的圆环

将数据key使用相同的函数Hash计算出哈希值

数据倾斜问题

对每个节点计算多个hash，设立虚拟值，新建编号
