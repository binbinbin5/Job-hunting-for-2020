[toc]


## 高频问题
**索引相关**



关于MySQL的索引,曾经进行过一次总结,文章链接在这里 Mysql索引原理及其优化.



**1. 什么是索引?**



索引是一种数据结构,可以帮助我们快速的进行数据的查找.



**2. 索引是个什么样的数据结构呢?**



索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有Hash索引,B+树索引等,而我们经常使用的InnoDB存储引擎的默认索引实现为:B+树索引.



**3. Hash索引和B+树所有有什么区别或者说优劣呢?**



首先要知道Hash索引和B+树索引的底层实现原理:



hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.



那么可以看出他们有以下的不同:

- hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.

因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.

- hash索引不支持使用索引进行排序,原理同上.
- hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.**AAAA**和**AAAAB**的索引没有相关性.
- hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.
- hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.

因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.



**4. 上面提到了B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据,什么是聚簇索引?**



在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据,这就是聚簇索引和非聚簇索引. 在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引.



当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.



**5. 非聚簇索引一定会回表查询吗?**



不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.



举个简单的例子,假设我们在员工表的年龄上建立了索引,那么当进行select age from employee where age < 20的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.



**6. 在建立索引的时候,都有哪些需要考虑的因素呢?**



建立索引的时候一般要考虑到字段的使用频率,经常作为条件进行查询的字段比较适合.如果需要建立联合索引的话,还需要考虑联合索引中的顺序.此外也要考虑其他方面,比如防止过多的所有对表造成太大的压力.这些都和实际的表结构以及查询方式有关.



**7. 联合索引是什么?为什么需要注意联合索引中的顺序?**



MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.



具体原因为:MySQL使用索引时需要索引有序,假设现在建立了"name,age,school"的联合索引,那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序.



当进行查询时,此时索引仅仅按照name严格有序,因此必须首先使用name字段进行等值查询,之后对于匹配到的列而言,其按照age字段严格有序,此时可以使用age字段用做索引查找,,,以此类推.因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.



**8. 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?**



MySQL提供了explain命令来查看语句的执行计划,MySQL在执行某个语句之前,会将该语句过一遍查询优化器,之后会拿到对语句的分析,也就是执行计划,其中包含了许多信息. 可以通过其中和索引有关的信息来分析是否命中了索引,例如possilbe_key,key,key_len等字段,分别说明了此语句可能会使用的索引,实际使用的索引以及使用的索引长度.



**9. 那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?**

- 使用不等于查询,
- 列参与了数学运算或者函数
- 在字符串like时左边是通配符.类似于'%aaa'.
- 当mysql分析全表扫描比使用索引快的时候不使用索引.
- 当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.

以上情况,MySQL无法使用索引.



**事务相关**



**1. 什么是事务?**



理解什么是事务最经典的就是转账的栗子,相信大家也都了解,这里就不再说一边了.



事务是一系列的操作,他们要符合ACID特性.最常见的理解就是:事务中的操作要么全部成功,要么全部失败.但是只是这样还不够的.



**2. ACID是什么?可以详细说一下吗?**



A=Atomicity



原子性,就是上面说的,要么全部成功,要么全部失败.不可能只执行一部分操作.



C=Consistency



系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态.



I=Isolation



隔离性: 通常来说:一个事务在完全提交之前,对其他事务是不可见的.注意前面的通常来说加了红色,意味着有例外情况.



D=Durability



持久性,一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果.



**3. 同时有多个事务在进行会怎么样呢?**



多事务的并发进行一般会造成以下几个问题:

- 脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.
- 不可重复读: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.
- 幻读: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成"幻觉".

**4. 怎么解决这些问题呢?MySQL的事务隔离级别了解吗?**



MySQL的四种隔离级别如下:

- 未提交读(READ UNCOMMITTED)

这就是上面所说的例外情况了,这个隔离级别下,其他事务可以看到本事务没有提交的部分修改.因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚).



这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.

- 已提交读(READ COMMITTED)

其他事务只能读取到本事务已经提交的部分.这个隔离级别有 不可重复读的问题,在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改.

- REPEATABLE READ(可重复读)

可重复读隔离级别解决了上面不可重复读的问题(看名字也知道),但是仍然有一个新问题,就是 幻读,当你读取id> 10 的数据行时,对涉及到的所有行加上了读锁,此时例外一个事务新插入了一条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥,那么进行本事务进行下一次的查询时会发现有一条id=11的数据,而上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题.

- SERIALIZABLE(可串行化)

这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用.



**5. Innodb使用的是哪种隔离级别呢?**



InnoDB默认使用的是可重复读隔离级别.



**6. 对MySQL的锁了解吗?**



当数据库有并发事务的时候,可能会产生数据的不一致,这时候需要一些机制来保证访问的次序,锁机制就是这样的一个机制.



就像酒店的房间,如果大家随意进出,就会出现多人抢夺同一个房间的情况,而在房间上装上锁,申请到钥匙的人才可以入住并且将房间锁起来,其他人只有等他使用完毕才可以再次使用.



**7. MySQL都有哪些锁呢?像上面那样子进行锁定岂不是有点阻碍并发效率了?**



从锁的类别上来讲,有共享锁和排他锁.



共享锁: 又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个.



排他锁: 又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.



用上面的例子来说就是用户的行为有两种,一种是来看房,多个用户一起看房是可以接受的. 一种是真正的入住一晚,在这期间,无论是想入住的还是想看房的都不可以.



锁的粒度取决于具体的存储引擎,InnoDB实现了行级锁,页级锁,表级锁.



他们的加锁开销从大大小,并发能力也是从大到小.



**表结构设计**



**1. 为什么要尽量设定一个主键?**



主键是数据库确保数据行在整张表唯一性的保障,即使业务上本张表没有主键,也建议添加一个自增长的ID列作为主键.设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全.



**2. 主键使用自增ID还是UUID?**



推荐使用自增ID,不要使用UUID.



因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.



总之,在数据量大一些的情况下,用自增主键性能会好一些.



*图片来源于《高性能MySQL》: 其中默认后缀为使用自增ID,_uuid为使用UUID为主键的测试,测试了插入100w行和300w行的性能.*

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190820130223.png)

关于主键是聚簇索引,如果没有主键,InnoDB会选择一个唯一键来作为聚簇索引,如果没有唯一键,会生成一个隐式的主键.



*If you define a PRIMARY KEY on your table, InnoDB uses it as the clustered index.
If you do not define a PRIMARY KEY for your table, MySQL picks the first UNIQUE index that has only NOT NULL columns as the primary key and InnoDB uses it as the clustered index.*



**3. 字段为什么要求定义为not null?**



MySQL官网这样介绍:



*NULL columns require additional space in the rowto record whether their values are NULL. For MyISAM tables, each NULL columntakes one bit extra, rounded up to the nearest byte.*



null值会占用更多的字节,且会在程序中造成很多与预期不符的情况.



**4. 如果要存储用户的密码散列,应该使用什么字段进行存储?**



密码散列,盐,用户身份证号等固定长度的字符串应该使用char而不是varchar来存储,这样可以节省空间且提高检索效率.



**存储引擎相关**



**1. MySQL支持哪些存储引擎?**



MySQL支持多种存储引擎,比如InnoDB,MyISAM,Memory,Archive等等.在大多数的情况下,直接选择使用InnoDB引擎都是最合适的,InnoDB也是MySQL的默认存储引擎.

1. InnoDB和MyISAM有什么区别?

- InnoDB支持事物，而MyISAM不支持事物
- InnoDB支持行级锁，而MyISAM支持表级锁
- InnoDB支持MVCC, 而MyISAM不支持
- InnoDB支持外键，而MyISAM不支持
- InnoDB不支持全文索引，而MyISAM支持。

**零散问题**



**1. MySQL中的varchar和char有什么区别.**



char是一个定长字段,假如申请了char(10)的空间,那么无论实际存储多少内容.该字段都占用10个字符,而varchar是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.



在检索效率上来讲,char > varchar,因此在使用中,如果确定某个字段的值的长度,可以使用char,否则应该尽量使用varchar.例如存储用户MD5加密后的密码,则应该使用char.



**2. varchar(10)和int(10)代表什么含义?**



varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度,而int的10只是代表了展示的长度,不足10位以0填充.也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.



**3. MySQL的binlog有有几种录入格式?分别有什么区别?**



有三种格式,statement,row和mixed.

- statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.
- row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.
- mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.

此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.



**4. 超大分页怎么处理?**



超大的分页一般从两个方向上来解决.

- 数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.
- 从需求的角度减少这种请求….主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.

解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.



在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.

![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs/20190820130332.png)

**5. 关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?**



在业务系统中,除了使用主键进行的查询,其他的我都会在测试库上测试其耗时,慢查询的统计主要由运维在做,会定期将业务中的慢查询反馈给我们.



慢查询的优化首先要搞明白慢的原因是什么? 是查询条件没有命中索引?是load了不需要的数据列?还是数据量太大?



所以优化也是针对这三个方向来的,

- 首先分析语句,看看是否load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写.
- 分析语句的执行计划,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引.
- 如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表.

**6. 上面提到横向分表和纵向分表,可以分别举一个适合他们的例子吗?**



横向分表是按行分表.假设我们有一张用户表,主键是自增ID且同时是用户的ID.数据量较大,有1亿多条,那么此时放在一张表里的查询效果就不太理想.我们可以根据主键ID进行分表,无论是按尾号分,或者按ID的区间分都是可以的. 假设按照尾号0-99分为100个表,那么每张表中的数据就仅有100w.这时的查询效率无疑是可以满足要求的.



纵向分表是按列分表.假设我们现在有一张文章表.包含字段id-摘要-内容.而系统中的展示形式是刷新出一个列表,列表中仅包含标题和摘要,当用户点击某篇文章进入详情时才需要正文内容.此时,如果数据量大,将内容这个很大且不经常使用的列放在一起会拖慢原表的查询速度.我们可以将上面的表分为两张.id-摘要,id-内容.当用户点击详情,那主键再来取一次内容即可.而增加的存储量只是很小的主键字段.代价很小.



当然,分表其实和业务的关联度很高,在分表之前一定要做好调研以及benchmark.不要按照自己的猜想盲目操作.



**7. 什么是存储过程？有哪些优缺点？**



存储过程是一些预编译的SQL语句。1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全



但是,在互联网项目中,其实是不太推荐存储过程的,比较出名的就是阿里的《Java开发手册》中禁止使用存储过程,我个人的理解是,在互联网项目中,迭代太快,项目的生命周期也比较短,人员流动相比于传统的项目也更加频繁,在这样的情况下,存储过程的管理确实是没有那么方便,同时,复用性也没有写在服务层那么好.



**8. 说一说三个范式**



第一范式: 每个列都不可以再拆分. 第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分. 第三范式: 非主键列只依赖于主键,不依赖于其他非主键.



在设计数据库结构的时候,要尽量遵守三范式,如果不遵守,必须有足够的理由.比如性能. 事实上我们经常会为了性能而妥协数据库的设计.



**9. MyBatis中的#**



乱入了一个奇怪的问题…..我只是想单独记录一下这个问题,因为出现频率太高了.



\# 会将传入的内容当做字符串,而有什么区别?∗∗乱入了一个奇怪的问题.....我只是想单独记录一下这个问题,因为出现频率太高了.#会将传入的内容当做字符串,而会直接将传入值拼接在sql语句中.



所以#可以在一定程度上预防sql注入攻击.
## 概念
### 内外连接的区别
- 内连接：两表都存在
- 外连接: 
    - 左外连接：以左为准，显示
    - 右外连接：以右为准，显示
    - 全外连接：全部显示

```
//信息表
id     name 
1      a    
2      b      
3      c
4      d

```

```
//成绩表
id     score
1      100
2      80
3      80 
4      90

```

```
select id name score for score name from name inner join score on s_id = n_id
//内连接
id     name    score
1      a       100  
2      b       80
3      c       80
4      d       90
```
```
select id name score for score name from name left outer join score on s_id = n_id
//外连接
id     name    score
1      a       100  
2      b       80
3      c       80
4      d       90
5      e
6      f
```


### 数据库水平切分，垂直切分
垂直拆分就是要把表按模块划分到不同数据库表中（当然原则还是不破坏第三范式），这种 拆分在大型网站的演变过程中是很常见的。当一个网站还在很小的时候，只有小量的人来开发和 维护，各模块和表都在一起，当网站不断丰富和壮大的时候，也会变成多个子系统来支撑，这时 就有按模块和功能把表划分出来的需求。其实，相对于垂直切分更进一步的是服务化改造，说得 简单就是要把原来强耦合的系统拆分成多个弱耦合的服务，通过服务间的调用来满足业务需求 看，因此表拆出来后要通过服务的形式暴露出去，而不是直接调用不同模块的表，淘宝在架构不 断演变过程，最重要的一环就是服务化改造，把用户、交易、店铺、宝贝这些核心的概念抽取成 独立的服务，也非常有利于进行局部的优化和治理，保障核心模块的稳定性。 垂直拆分：单表大数据量依然存在性能瓶颈 

水平拆分，上面谈到垂直切分只是把表按模块划分到不同数据库，但没有解决单表大数据量 的问题，而水平切分就是要把一个表按照某种规则把数据划分到不同表或数据库里。例如像计费 系统，通过按时间来划分表就比较合适，因为系统都是处理某一时间段的数据。而像 SaaS 应用， 通过按用户维度来划分数据比较合适，因为用户与用户之间的隔离的，一般不存在处理多个用户 数据的情况，简单的按 user_id 范围来水平切分。 

通俗理解：水平拆分行，行数据拆分到不同表中， 垂直拆分列，表数据拆分到不同表中。

### mysql 主从复制？ 

 主从复制是其最重要的功能之一。主从复制是指一台服务器充当主数据库服务器，另 一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。对于多级 复制，数据库服务器即可充当主机，也可充当从机。MySQL 主从复制的基础是主服务器对数据库 修改记录二进制日志，从服务器通过主服务器的二进制日志自动执行更新。 MySQL 
 
 主从复制的两种情况：同步复制和异步复制，实际复制架构中大部分为异步复制。 
 
 复制的基本过程如下：
 
 Slave 上面的 IO 进程连接上 Master，并请求从指定日志文件的指定位置（或者从最开始的 日志）之后的日志内容。 
 
 Master 接收到来自 Slave 的 IO 进程的请求后，负责复制的 IO 进程会根据请求信息读取日 志指定位置之后的日志信息，返回给 Slave 的 IO 进程。返回信息中除了日志所包含的信息之外， 还包括本次返回的信息已经到 Master 端的 bin-log 文件的名称以及 bin-log 的位置。 
 
 Slave 的 IO 进程接收到信息后，将接收到的日志内容依次添加到 Slave 端的 relay-log 文 件的最末端，并将读取到的 Master 端的 bin-log 的文件名和位置记录到 master-info 文件中， 以便在下一次读取的时候能够清楚的告诉 Master“我需要从某个 bin-log 的哪个位置开始往后 的日志内容，请发给我”。

Slave 的 Sql 进程检测到 relay-log 中新增加了内容后，会马上解析 relay-log 的内容成为 在 Master 端真实执行时候的那些可执行的内容，并在自身执行。

### 如何设计一个数据库
![](https://raw.githubusercontent.com/binbinbin5/myPics/master/imgs20190611203309.png)
根据数据库三范式来进行表结构的设计。设计表结构时，就需要考虑如何设计才能更有效的查询。

数据库三范式： 
1. 第一范式：数据表中每个字段都必须是不可拆分的最小单元，也就是确保每一列的原子性； 
1. 第二范式：满足一范式后，表中每一列必须有唯一性，都必须依赖于主键； 
1. 第三范式：满足二范式后，表中的每一列只与主键直接相关而不是间接相关(外键也是直接相关)，字段没有冗余。

注意：没有最好的设计，只有最合适的设计，所以不要过分注重理论。三范式可以作为一个基本依据，不要生搬硬套。

有时候可以根据场景合理地反规范化： 
1. A：分割表。 
1. B：保留冗余字段。当两个或多个表在查询中经常需要连接时，可以在其中一个表上增加若干冗余的字段，以 避免表之间的连接过于频繁，一般在冗余列的数据不经常变动的情况下使用。 
1. C：增加派生列。派生列是由表中的其它多个列的计算所得，增加派生列可以减少统计运算，在数据汇总时可以大大缩短运算时间。

数据库五大约束： 
- A：PRIMARY key:设置主键约束； 
- B：UNIQUE：设置唯一性约束，不能有重复值； 
- C：DEFAULT 默认值约束 
- D：NOT NULL：设置非空约束，该字段不能为空； 
- E：FOREIGN key :设置外键约束。

字段类型选择： 
- A：尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED 
- B：VARCHAR的长度只分配真正需要的空间 
- C：使用枚举或整数代替字符串类型 
- D：尽量使用TIMESTAMP而非DATETIME 
- E：单表不要有太多字段，建议在20以内 
- F：避免使用NULL字段，很难查询优化且占用额外索引空间

### 与Oracle相比，Mysql有什么优势？

Mysql是开源软件，随时可用，无需付费。

Mysql是便携式的

带有命令提示符的GUI。

使用Mysql查询浏览器支持管理
### Mysql的技术特点是什么？

Mysql数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程SQL服务器、不同的后端、广泛的应用程序编程接口和管理工具。

### 结构设计
（1）概念结构设计。这是数据库设计的第一个阶段，在管理信息系统的分析阶段，已经得到了系统的数据流程图和数据字典，现在要结合数据规范化的理论，用一种数据模型将用户的数据需求明确地表示出来。
概念数据模型是面向问题的模型，反映了用户的现实工作环境，是与数据库的具体实现技术无关的。建立系统概念数据模型的过程叫做概念结构设计。

（2）逻辑结构设计。根据已经建立的概念数据模型，以及所采用的某个数据库管理系统软件的数据模型特性，按照一定的转换规则，把概念模型转换为这个数据库管理系统所能够接受的逻辑数据模型。不同的数据库管理系统提供了不同的逻辑数据模型，如层次模型、网状模型、关系模型等。

（3）物理结构设计。为一个确定的逻辑数据模型选择一个最适合应用要求的物理结构的过程，就叫做数据库的物理结构设计。数据库在物理设备上的存储结构和存取方法称为数据库的物理数据模型。
### 模式
- 模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。
- 外模式也称为子模式或用户模式，它是数据库用户能够看到和使用的局部数据的逻辑结构和特征描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。
- 内模式也称为存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。

### Heap表是什么？

HEAP表存在于内存中，用于临时高速存储。

BLOB或TEXT字段是不允许的

只能使用比较运算符=，<，>，=>，= <

HEAP表不支持AUTO_INCREMENT

索引不可为NULL

### Mysql服务器默认端口是什么？

Mysql服务器的默认端口是3306。

### CHAR和VARCHAR的区别？

以下是CHAR和VARCHAR的区别：

CHAR和VARCHAR类型在存储和检索方面有所不同

- CHAR的长度是固定的，而VARCHAR2的长度是可以变化的

- 定义一个char[10]和varchar[10],如果存进去的是‘abcd’,那么char所占的长度依然为10，除了字符‘abcd’外，后面跟六个空格，而varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的，
- char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率，而varchar是以空间效率为首位的。
- char的存储方式是，对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节；而varchar的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节，两者的存储数据都非unicode的字符数据。

### 如何区分FLOAT和DOUBLE？

以下是FLOAT和DOUBLE的区别：

浮点数以8位精度存储在FLOAT中，并且有四个字节。

浮点数存储在DOUBLE中，精度为18位，有八个字节。

### 区分CHAR_LENGTH和LENGTH？

CHAR_LENGTH是字符数，而LENGTH是字节数。Latin字符的这两个数据是相同的，但是对于Unicode和其他编码，它们是不同的。


### union和union all
- union：表求并集的适合 去掉重复元素
- union all：只是简单两个表合并

### 日志满了怎么办
日志一般以循环的方式进行读写，日志满了只会允许查询，其他则不能执行。

## 索引
### 索引概念
索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中 的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于 更快地获取信息。索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽 快的找到符合限制条件的记录 ID 的辅助数据结构。InnoDB 主要面向在线事务处理（OLTP）的应 用。MyISAM 主要面向一些 OLAP 的应用。

- 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引

- 唯一索引：索引列的值必须唯一，但允许有空值

- 复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并

- 聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。

- 非聚簇索引：不是聚簇索引，就是非聚簇索引

1. MySQL使用B+Tree作为索引数据结构。
2. B+Tree在新增数据时，会根据索引指定列的值对旧的B+Tree做调整。
3. 从物理存储结构上说，B-Tree和B+Tree都以页(4K)来划分节点的大小，但是由于B+Tree中中间节点不存储数据，因此B+Tree能够在同样大小的节点中，存储更多的key，提高查找效率。
4. 影响MySQL查找性能的主要还是磁盘IO次数，大部分是磁头移动到指定磁道的时间花费。
5. MyISAM存储引擎下索引和数据存储是分离的，InnoDB索引和数据存储在一起。
6. InnoDB存储引擎下索引的实现，(辅助索引)全部是依赖于主索引建立的(辅助索引中叶子结点存储的并不是数据的地址，还是主索引的值，因此，所有依赖于辅助索引的都是先根据辅助索引查到主索引，再根据主索引查数据的地址)。
7. 由于InnoDB索引的特性，因此如果主索引不是自增的(id作主键)，那么每次插入新的数据，都很可能对B+Tree的主索引进行重整，影响性能。因此，尽量以自增id作为InnoDB的主索引。
### 为什么需要索引
避免全表扫描，提升查找速度

数据库最小的存储单位是块和页，当我们需要查询，全表扫描，加载块和页，一个个轮寻查找，这样速度非常的慢。（少量数据适合，大量数据不适合）索引灵感来自与字典，索引的速度很快。

### 什么信息可以成为索引
可以把记录限定在一定范围内的数据。
- 主键
- 唯一键，普通键

### 底层怎么实现的，什么时候会失效
B+树实现的。 

- 没有遵循最左匹配原则失效
- 一些关键字会导致索引失效，例如 or， ！= ， not in，is null ,is not unll like 
- 查询是以%开头 隐式转换会导致索引失效。 
- 对索引应用内部函数，索引字段进行了运算失效。

### 索引的数据结构
- 二叉树进行二分查找
- B-
- B+（主流）
- Hash
- bitMap（Oracle）

### 索引为何不采用红黑树

- 红黑树	增加删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间
- B树也就是B-树	B树，查询性能不稳定，查询结果高度不致，每个结点保存指向真实数据的指针，相比B+树每一层每屋存储的元素更多，显得更高一点。
- B+树	B+树相比较于另外两种树,显得更矮更宽，查询层次更浅

### 为什么要用 B+tree作为MySQL索引的数据结构
- 二叉树的增加删除缺点是会形成一个一条链表 查询时间O（N）
- 二叉平衡树虽然时间O（logN）缺点是数据库数据增加删除，树需要改动，比较复杂
- B树增加和删除节点对于整体的结构来说，改动非常的小，而且树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下，B树比较矮胖，适应IO。而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的，查询的时间复杂度是O(log2N)。
- 相比B树，B+树的磁盘读写代价更低，而且他的叶子节点存放值，使得查询更加稳点，B树只适合随机检索，而B+树同时支持随机检索和顺序检索；B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。

### Hash只需要一次就能定位，查询效率高，为什么不用它？
- 但是Hash索引不能使用范围查询，只能用（=）（IN）
- 无法被用来避免数据的排序操作
- 不能用部分索引键查询
- 不能避免表扫描
- Hash冲突，性能低

### 为什么官方建议使用自增长主键作为索引？

结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。

### 为什么使用B+树？言简意赅，就是因为：
1. 磁盘读写代价低，内部节点只存放指针而不是数据，比B树更小
2. 查询效率稳定，任何查找都是根节点到叶子节点的路
3. B+数更有利于数据库扫描，范围查询


### 密集索引和稀疏索引
- 密集索引文件中的每个搜索吗值都对应一个索引值（密集索引保存不仅仅键值，还有其他信息）
- 稀疏索引文件只为索引码的某些值建立索引项（只保存了键值和地址），稀疏索引两次索引 ，第一次查找到值，第二次以值来进行查找获取整条数据


- InnoDB若一个主键被定义，那么该主键则作为密集索引，若没有主键被定义，那么唯一非空索引为机密索引，若还不满足，则内部自动生产一个隐藏主键（一定要存在，因为非主键索引存储相关键位和其对应的主键值，包含两次查找 ，数据索引在一起）

- MyISAM则采用稀疏索引，两颗树存储内容不一样，一颗存储key一颗存储内容（数据索引分开）

### 如何定位并优化慢查询
- 慢日志定位慢SQL，（show variables like %X%,设置查看地址，时间）
    - show status %slow_queriea% 慢查询数量 
    - set galobal slow_query_log = on 打开慢查询日志
    - set long_query_time = 1 设置1秒，超过1秒记录到日志
    - 打开慢日志地址：花费时间，哪条语句
- explain 语句分析
    - 看type（找寻方式）和 extra(索引排序) 
- 修改sql尽量走索引

### explain
- select_type : 查询类型，有简单查询、联合查询、子查询等
    - ALL: 全表扫描
    - index: 索引全扫描
    - range:索引范围扫描
    - ref:使用非唯一索引扫描
    - eq_ref:使用唯一索引扫描
    - const，system:单表中最多只有一个匹配行
- key : 使用的索引
- rows : 扫描的行数
- Extra：关于MYSQL如何解析查询的额外信息坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢

### 联合索引的最左匹配原则

如果 联合索引（A,B,C,D）：一直向右遇到（<,>,between,like）就停止
- A =  and B = and C = and D = 走联合索引
- A = 走联合索引
- B =  不走联合索引
- B = and A = 走联合索引（= 和 in可以乱序，查询优化器会优化）
- A = and B = and C > and D =6 索引走到C

 

### 索引越多越好吗
当然不是了
- 数据量小的表格不需要 
- 更多的索引需要更多空间和维护成本

#

## 锁
### mysql都有什么锁

锁的粒度：页级、表级、行级。
- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。（对一张表的某行数据执行操作，整个表都会锁）
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。（对一张表进行操作，只锁住针对的那行数据，不会影响其他行数据）
- 页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

无论表还是行锁，都是锁按照级别：
- 读锁：对其他读不上锁，对写上锁（共享锁） lock in share mode
- 写锁：对读和写都上锁（排它锁）for update

按照加锁方式：
- 自动锁（update,delete..mysql自动为我们上）
- 显示锁 (我们自己加的，for update,lock in share mode)

操作划分
- DML：增删改查
- DDL：表结构

使用方式
- 乐观锁：在对数据进行提交的时候才进行检测（用版本号，时间戳）
- 悲观锁：持保守悲观态度，每次先取锁在执行

算法：
- next KeyLocks锁，同时锁住记录(数据)，并且锁住记录前面的Gap 
- Gap锁，不锁记录，仅仅记录前面的Gap
- Recordlock锁（锁数据，不锁Gap）
- 所以其实 Next-KeyLocks=Gap锁+ Recordlock锁

### MyIsam和InnoDB关于锁方面的区别是什么
- MyIsAM默认表级锁，不支持行级锁，不支持事务。适合频繁执行全表，对数据增删改少，查多。没有事务。
- InnoDB默认行级锁，可以使用表级锁。适合增删改，可靠性要求高，支持事务

### 数据库的四大特性
ACID
- 原子性：事务包含操作要么全做，要么全部做
- 一致性：数据库一个到另一个操作保持一致（转账，AB账号共2000，无论怎么转，A和B加起来还是2000）
- 隔离性：一个事务执行不影响其他
- 持久性：发生故障时，保持数据库，确保更新不丢失，比如InnoDB的（redo log）


### InnoDB可重复读隔离级别下如何避免幻读

区间锁（GAP lock）, 仅仅锁住一个索引区间（开区间，不包括双端端点）。
在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。

间隙锁可用于防止幻读，保证索引间的不会被插入数据
- 如果where条件全部命中,那么不会用gap锁
- 如果where条件部分命中或者全部命中,则会加gap锁

### RC,RR下的InnoDB的非阻塞读（快照读）
- 当前读：加了锁的记录
- 当前读：增删改
- 快照读：不加锁的非阻塞读：没有加锁读到之前的操作

通过undo日志和read view，取出之前的值


### 失误隔离级别下的并发访问问题

1. read uncommited ：读到未提交数据（解决更新丢失）
1. read committed：读已提交（解决脏读）
1. repeatable read：可重读（解决不可重复读）
1. serializable ：串行事物（解决幻影读）





### 什么情况下会造成死锁

所谓死锁<DeadLock>: 是指两个或两个以上的进程在执行过程中,
因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.

此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程.

表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.

==死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。那么对应的解决死锁问题的关键就是：让不同的session加锁有次序==


### MYSQL支持事务吗？

在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。

但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。

示例如下：
```
一

START TRANSACTION;

SELECT @A:=SUM(salary) FROM table1 WHERE type=1;

UPDATE table2 SET summmary=@A WHERE type=1;

COMMIT;
```
### 请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？

SQL标准定义的四个隔离级别为：

1. read uncommited ：读到未提交数据
1. read committed：脏读，不可重复读
1. repeatable read：可重读
1. serializable ：串行事物

详细解释如下：
- Read Uncommitted（读取未提交内容）
在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

- Read Committed（读取提交内容）
这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。==乐观锁或者悲观锁把相关行数据锁住解决不可重复度==

- Repeatable Read（可重读）
这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。==innodb采用间隙所解决幻影读==

- Serializable（可串行化）
这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
对于不同的事务，采用不同的隔离级别分别有不同的结果。不同的隔离级别有不同的现象。主要有

下面3种现在：
- 1、脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。
- 2、非重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。
- 3、幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。
不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差，4种事务隔离级别分别表现的现象如下表：
![](https://ws1.sinaimg.cn/large/006DGX4tly1fvjufj9m9gj30h704it8n.jpg)

### 预防死锁

那么，如何尽可能的避免死锁呢？

1）以固定的顺序访问表和行。即按顺序申请锁，这样就不会造成互相等待的场面。

2）大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。

3）在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。

4）降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。

5）为表添加合理的索引。如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。
## 存储引擎
### InnoDB与MyISAM
存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景
主要区别：

1. MyISAM是非事务安全型的，而InnoDB是事务安全型的。
1. MyISAM锁的粒度是表级，而InnoDB支持行级锁定。
1. MyISAM支持全文类型索引，而InnoDB不支持全文索引。
1. MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。
1. MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。
1. InnoDB表比MyISAM表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。

应用场景：

1. M yISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。
2. InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。

### Mysql中使用什么存储引擎？

存储引擎称为表类型，数据使用各种技术存储在文件中。

技术涉及：

Storage mechanism

Locking levels

Indexing

Capabilities and functions.
### MyISAM表格将在哪里存储，并且还提供其存储格式？

每个MyISAM表格以三种格式存储在磁盘上：

·“.frm”文件存储表定义

·数据文件具有“.MYD”（MYData）扩展名

索引文件具有“.MYI”（MYIndex）扩展名
### Mysql中有哪些不同的表格？

共有5种类型的表格：
```
MyISAM

Heap

Merge

INNODB

ISAM
```

MyISAM是Mysql的默认存储引擎。

### MISAM是什么？

MISAM简称为索引顺序访问方法。它是由IBM开发的，用于在磁带等辅助存储系统上存储和检索数据。

### InnoDB是什么？

lnnoDB是一个由Oracle公司开发的Innobase Oy事务安全存储引擎。

## 语法
### BROUP BY,WHERE 
分组进行计算
```
select student.name,score.id,count(score.course),sum(score.score)
from score，student
where score.id = student.id
group by id  
```
having只能用在group by之后，对分组后的结果进行筛选，筛选行(即使用having的前提条件是分组)。
where肯定在group by 之前
where后的条件表达式里不允许使用聚合函数，而having可以。
group by 通常和集合函数SUM(),AVG().MAX(),MIN(),COUNT()等结合在一起，后接限制条件语句 having,不可用where语句！

### Having和where区别
- having通常与GROUD BY一起使用：
- where过滤行，having过滤组
- 顺序：where>groud by>having


```
select student_id,AVG(score)
from score
groud by student_id
having AVG(score)>60
```

### 一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？

1.如果表的类型是MyISAM，那么是18.因为MyISAM会把自己增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失。  
2.如果表的类型是InnoDB，那么是15.InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失。


### 范式


范式理论是为了解决以上提到四种异常。

高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。

关键码 
- 1) 超键：在关系中能唯一标识元组的属性或属性集称为关键模式的超键。 
- 2) 候选键：不含有多余属性的超键称为候选键。也就是在候选键中在删除属性就不是键了。 
- 3) 主键：用户选作元组标识的候选键称为主键。一般不加说明，键就是指主键。 
- 4) 外键：如果模式R中属性K是其他模式的主键，那么K在模式R中称为外键。



==完全依赖、部分依赖、传递依赖==
- 部分函数依赖：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。 
举个例子：学生基本信息表R中（学号，身份证号，姓名）当然学号属性取值是唯一的，在R关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖与（学号，身份证号）； 
- 完全函数依赖：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。 
例子：学生基本信息表R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在R关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；

- 传递函数依赖：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。 
例子：在关系R(学号 ,宿舍, 费用)中，(学号)->(宿舍),宿舍！=学号，(宿舍)->(费用),费用!=宿舍，所以符合传递函数的要求；



### 1. 第一范式 (1NF)

属性不可分。第一范式是指数据库的每一列都是不可分割的基本数据项，强调列的原子性，试题中某一属性不能拥有几个值。

### 2. 第二范式 (2NF)

每个非主属性完全函数依赖于键码。除满足第一范式外还有两个条件，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。

- 当主键只有一个属性的时候，是要有主键就是第二范式！
- 当主键包含多个属性的时候，必须满足每个非主属性都完全函数依赖于主键，也就说主键的真子集都不能决定非主属性！只有主键才能决定所有非主属性。

```
示例：（以下例子 不符合 第二范式）

/*学号    课程号     得分    课程名*/
  Sno      Cno      Score    Sname
  1001     001       99      数据库
主键： Sno,Cno

不满足原因：Sname不完全依赖于码，课程名部分依赖于码Cno。

```

### 3. 第三范式 (3NF)

每一个非主属性==都不传递依赖于该范式==的候选键。
```
示例：（以下例子 不符合 第三范式）

/*学号     系别     系主任*/
  Sno     Sdept     Shead
  1001   计算机系    张三

主键：Sno
不满足原因：Shead传递依赖于码，Sno->Sdept->Shead，可得Sno->Shead。
```
### BCNF
BCNF 在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合第三范式。

- （1）所有非主属性对每一个码都是完全函数依赖； 
- （2）所有的主属性对于每一个不包含它的码，也是完全函数依赖； 
- （3）没有任何属性完全函数依赖于非码的任意一个组合。
```
示例：（以下例子不符合第BCNF范式）

/*学生       老师        课程*/
  Stu      Teacher      Course
  张三       李开复       数据库


假设：每个老师只教一门课。
候选码：
(Stu,Teacher)->Course
(Stu,Course)->Teacher

这两个码由两个属性组成，而且它们是相互交叉的，所以不存在传递依赖，所以为3NF。

但是由于：Teacher->Course，（主键的一部分被另一部分决定），所以不符合BCNF。
```




### 在Mysql中ENUM的用法是什么？

ENUM是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。

Create table size(name ENUM('Smail,'Medium','Large');

### 如何定义REGEXP？

REGEXP是模式匹配，其中匹配模式在搜索值的任何位置。



### 列的字符串类型可以是什么？

字符串类型是：

SET

BLOB

ENUM

CHAR

TEXT

VARCHAR

### 如何获取当前的Mysql版本？

SELECT VERSION();用于获取当前Mysql的版本。



### Mysql驱动程序是什么？

以下是Mysql中可用的驱动程序：

PHP驱动程序

JDBC驱动程序

ODBC驱动程序

CWRAPPER

PYTHON驱动程序

PERL驱动程序

RUBY驱动程序

CAP11PHP驱动程序

Ado.net5.mxj

### TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？

创建表时TIMESTAMP列用Zero更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP修饰符就将时间戳字段更新为当前时间。

### 主键和候选键有什么区别？

表格的每一行都由主键唯一标识,一个表只有一个主键。

主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。

### 如何使用Unix shell登录Mysql？

我们可以通过以下命令登录：
``` sql
# [mysql dir]/bin/mysql -h hostname -u -p
```

### myisamchk是用来做什么的？

它用来压缩MyISAM表，这减少了磁盘或内存使用。

### MYSQL数据库服务器性能分析的方法命令有哪些?

Show status

一些值得监控的变量值：

Bytes_received和Bytes_sent

和服务器之间来往的流量。

Com_*服务器正在执行的命令。

Created_*在查询执行期限间创建的临时表和文件。

Handler_*存储引擎操作。

Select_*不同类型的联接执行计划。

Sort_*几种排序信息。

Show session status like ‘Select’;

Show profiles

SET profiling=1;

Show profiles \G

Show profile;

### 如何控制HEAP表的最大尺寸？

Heal表的大小可通过称为max_heap_table_size的Mysql配置变量来控制。

### MyISAM Static和MyISAM Dynamic有什么区别？

在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。点击这里有一套最全阿里面试题总结。

MyISAM Static在受损情况下更容易恢复。

### federated表是什么？

federated表，允许访问位于其他服务器数据库上的表。

### 如果一个表有一列定义为TIMESTAMP，将发生什么？

每当行被更改时，时间戳字段将获取当前时间戳。

### 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？

它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。

### 怎样才能找出最后一次插入时分配了哪个自动增量？

LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。

### 你怎么看到为表格定义的所有索引？

索引是通过以下方式为表格定义的：

SHOW INDEX FROM ;

### LIKE声明中的％和_是什么意思？

％对应于0个或更多字符，_ 只是LIKE语句中的一个字符。

### 如何在Unix和Mysql时间戳之间进行转换？

UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令

FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令

### 列对比运算符是什么？

在SELECT语句的列比较中使用=，<>，<=，<，> =，>，<<，>>，<=>，AND，OR或LIKE运算符。

### 我们如何得到受查询影响的行数？

行数可以通过以下代码获得：

SELECT COUNT(user_id)FROM users;

### Mysql查询是否区分大小写？

不区分
``` sql
SELECT VERSION(), CURRENT_DATE;

SeLect version(), current_date;

seleCt vErSiOn(), current_DATE;
```
所有这些例子都是一样的，Mysql不区分大小写。

### LIKE和REGEXP操作有什么区别？

LIKE和REGEXP运算符用于表示^和％。
``` sql
SELECT * FROM employee WHERE emp_name LIKE "%b";

SELECT * FROM employee WHERE emp_name REGEXP "^b";
```

### BLOB和TEXT有什么区别？

BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB -

TINYBLOB

BLOB

MEDIUMBLOB和

LONGBLOB

它们只能在所能容纳价值的最大长度上有所不同。

TEXT是一个不区分大小写的BLOB。四种TEXT类型

TINYTEXT

TEXT

MEDIUMTEXT和

LONGTEXT

它们对应于四种BLOB类型，并具有相同的最大长度和存储要求。

BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。

### mysql_fetch_array和mysql_fetch_object的区别是什么？

以下是mysql_fetch_array和mysql_fetch_object的区别：

- mysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。

- mysql_fetch_object - 从数据库返回结果行作为对象。

### 我们如何在mysql中运行批处理模式？

以下命令用于在批处理模式下运行：
``` sql
mysql;

mysql mysql.out
```




### Mysql如何优化DISTINCT？

DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。
``` sql
SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;
```

### 如何输入字符为十六进制数字？

如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X），或者只用（Ox）前缀输入十六进制数字。

如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。

### 如何显示前50行？

在Mysql中，使用以下代码查询显示前50行：
``` sql
SELECT*FROM

LIMIT 0,50;
```

### 可以使用多少列创建索引？

任何标准表最多可以创建16个索引列。

### NOW（）和CURRENT_DATE（）有什么区别？

NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。

CURRENT_DATE（）仅显示当前年份，月份和日期。

### 什么样的对象可以使用CREATE语句创建？

以下对象是使用CREATE语句创建的：
```
DATABASE

EVENT

FUNCTION

INDEX

PROCEDURE

TABLE

TRIGGER

USER

VIEW
```

### Mysql表中允许有多少个TRIGGERS？

在Mysql表中允许有六个触发器，如下：
```
BEFORE INSERT

AFTER INSERT

BEFORE UPDATE

AFTER UPDATE

BEFORE DELETE

AFTER DELETE
```

### 什么是非标准字符串类型？

以下是非标准字符串类型：
```
TINYTEXT

TEXT

MEDIUMTEXT

LONGTEXT
```

### 什么是通用SQL函数？

```
CONCAT(A, B) - 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。

FORMAT(X, D)- 格式化数字X到D有效数字。

CURRDATE(), CURRTIME()- 返回当前日期或时间。

NOW（） - 将当前日期和时间作为一个值返回。

MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） - 从日期值中提取给定数据。

HOUR（），MINUTE（），SECOND（） - 从时间值中提取给定数据。

DATEDIFF（A，B） - 确定两个日期之间的差异，通常用于计算年龄

SUBTIMES（A，B） - 确定两次之间的差异。

FROMDAYS（INT） - 将整数天数转换为日期值。
```

### 解释访问控制列表

ACL（访问控制列表）是与对象关联的权限列表。这个列表是Mysql服务器安全模型的基础，它有助于排除用户无法连接的问题。

Mysql将ACL（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，Mysql会按照预定的顺序检查ACL的认证信息和权限。



### mysql里记录货币用什么字段类型好

NUMERIC和DECIMAL类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；点击这里有一套最全阿里面试题总结。

例如：

salary DECIMAL(9,2)

在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。

因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。在ANSI/ISO SQL92中，句法DECIMAL(p)等价于DECIMAL(p,0)。

同样，句法DECIMAL等价于DECIMAL(p,0)，这里实现被允许决定值p。Mysql当前不支持DECIMAL/NUMERIC数据类型的这些变种形式的任一种。

这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的能力。

DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。

一个字符用于值的每一位、小数点(如果scale>0)和“-”符号(对于负值)。如果scale是0，DECIMAL和NUMERIC值不包含小数点或小数部分。

DECIMAL和NUMERIC值得最大的范围与DOUBLE一样，但是对于一个给定的DECIMAL或NUMERIC列，实际的范围可由制由给定列的precision或scale限制。

当这样的列赋给了小数点后面的位超过指定scale所允许的位的值，该值根据scale四舍五入。

当一个DECIMAL或NUMERIC列被赋给了其大小超过指定(或缺省的）precision和scale隐含的范围的值，Mysql存储表示那个范围的相应的端点值。

我希望本文可以帮助你提升技术水平。那些，感觉学的好难，甚至会令你沮丧的人，别担心，我认为，如果你愿意试一试本文介绍的几点，会向前迈进，克服这种感觉。这些要点也许对你不适用，但你会明确一个重要的道理：接受自己觉得受困这个事实是摆脱这个困境的第一步。

### MYSQL数据表在什么情况下容易损坏？

服务器突然断电导致数据文件损坏。

强制关机，没有先关闭 mysql 服务等。

### mysql有关权限的表都有哪几个？

Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。



